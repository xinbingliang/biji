# 管道

1. 全局变量加锁

   `````go
   package main

   import (
   	"fmt"
   	"time"
   )

   var (
   	myMap = make(map[int]int, 10)
   	//lock sync.Mutex  //全局锁
   )

   func test(n int) {
   	res := 1
   	for i := 1; i < n; i++ {
   		res *= i
   	}
   	//lock.Lock()
   	myMap[n] = res
   	//lock.Unlock()
   }

   func main() {
   	for i := 1; i <= 20; i++ {
   		go test(i)
   	}
   	time.Sleep(time.Second * 5)

   	//lock.Lock()
   	for i, v := range myMap {
   		fmt.Printf("map [%d]=%d\n", i, v)
   	}
   	//lock.Unlock()
   }
   `````

2. 管道

   * channle本质是一个队列数据结构
   * 线程安全，无资源竞争问题
   * 只能单一类型

   `````go
   package main

   import "fmt"

   func main() {
   	//创建一个可以存放3个int类型的管道,不能自动增长
   	var intChan chan int
   	intChan = make(chan int, 3)

   	//查看intChan
   	fmt.Printf("%v ==== %v\n", &intChan, intChan)

   	//向管道写入数据
   	intChan<- 10
   	num := 111
   	intChan<- num

   	//查看管道的长度和cap
   	fmt.Printf("长度%v 容量%v\n", len(intChan), cap(intChan))

   	//从管道中读取
   	var num2 int
   	num2 = <-intChan
   	fmt.Println(num2)
   	num2 = <-intChan
   	num2 = <-intChan   //deadlock!
   }
   `````

   ## 练习

   ````go
   package main

   import "fmt"

   type Cat struct {
   	Name string
   	Age  int
   }

   func main() {
   	//定义一个存放任意数据类型的管道
   	var allChan chan interface{}
   	allChan = make(chan interface{}, 3)
   	//allChan := make(chan interface{}, 3)

   	allChan<- 10
   	allChan<- "xin"
   	cat := Cat{Name: "花猫", Age: 20}
   	allChan<- cat

   	//获得第三个元素
   	<- allChan
   	<- allChan
   	newCat := <- allChan

   	fmt.Printf("类型%T, 值%v\n", newCat, newCat)
   	a := newCat.(Cat)
   	fmt.Printf("name=%v\n", a)
   }
   ````

## 遍历

```go 
package main

import "fmt"

func main() {
	intChan2 := make(chan int, 100)

	for i := 0; i < 100; i++ {
		intChan2 <- i * 2
	}

	//不能使用普通的for-in读取
	//遍历时如果channel没有关闭，则会出现deadLock错误
	//在遍历时，若channel已经关闭，则会正常遍历数据。遍历后，会退出
	close(intChan2)
	for v := range intChan2 {
		fmt.Println("v=", v)
	}
}
```

## 协程和管道

````go
package main

import (
	"fmt"
)

func writeData(intChan chan int) {
	for i := 1; i <= 50; i++ {
		intChan <- i
		fmt.Println("写入数据", i)
		//time.Sleep(time.Second)
	}
	close(intChan)
}

func redData(intChan chan int, exitChan chan bool) {
	for {
		v, ok := <-intChan
		if !ok {
			break
		}
		//time.Sleep(time.Second)
		fmt.Printf("redData读取的数据是=%v\n", v)
	}
	// 读取完成即任务完成
	exitChan <- true
	close(exitChan)
}

func main() {
	//创建两个管道
	intChan := make(chan int, 50)
	exitChan := make(chan bool, 1)
	go writeData(intChan)
	go redData(intChan, exitChan)
	//time.Sleep(time.Second * 20)

	for {
		_, ok := <-exitChan
		if !ok {
			//读到内容就退出
			break
		}
	}
}
````





