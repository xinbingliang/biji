#  面向对象高级

## 工厂模式

* go结构体没有构造函数，使用工厂模式

  `````
  +--factory
  | +--main
  | | +--main.go
  | +--model
  | | +--student.go
  +--tree.py
  `````

  * `main.go`

    ````go
    package model

    //定义一个结构体
    //type student struct {
    //	Name string
    //	Age int
    //}

    type student struct {
    	Name string
    	age int
    }

    //func NewStudent(n string, a int) *student {
    //	return &student{
    //		Name: n,
    //		Age: a,
    //	}
    //}

    func NewStudent(n string, a int) *student {
    	return &student{
    		Name: n,
    		age: a,
    	}
    }

    //若Age 为小写，解决方式
    func (s *student) Get_age() int{ //像不像其他编程中的私有变量访问
    	return s.age
    }
    ````

  * `student.go`

    ```go
    package main

    import (
    	"fmt"
    	"gotest/factory/model"
    )

    func main() {
    	//var stu = model.Student{
    	//	Name: "tom",
    	//	Age: 29,
    	//}
    	//
    	//fmt.Println(stu)

    	//首字母小写时
    	var stu = model.NewStudent("崔", 16)
    	fmt.Println(stu)
    	fmt.Println(stu.Get_age())
    }
    ```

  ​

## 封装

* 控制对对象资源的设置和访问

## 继承

* 同类对象代码复用问题

  `````go
  package main

  import "fmt"

  type student struct {
  	Name string
  	Age int
  	Score int
  }

  func (stu *student) ShowInfo () {
  	fmt.Printf("学生名=%v，年龄=%v，成绩=%v\n", stu.Name, stu.Age, stu.Score)
  }

  type Pupil struct {
  	student //嵌入student匿名结构体
  }

  type Graduate struct {
  	student
  }

  func (p *Pupil) testing()  {
  	fmt.Println("小学生考试中......")
  	p.Score = 100
  }

  func (p *Graduate) testing()  {
  	fmt.Println("大学生考试中......")
  	p.Score = 97
  }

  func main() {
  	var pupil = &Pupil{}
  	pupil.student.Name = "崔"
  	pupil.student.Age = 8
  	pupil.testing()
  	pupil.ShowInfo()

  	var graduate = &Graduate{}
  	graduate.student.Name = "学"
  	graduate.student.Age = 8
  	graduate.testing()
  	graduate.ShowInfo()
  }
  `````

### 简化访问

````go
package main

import "fmt"

type student struct {
	Name string
	Age int
	Score int
}

func (stu *student) ShowInfo () {
	fmt.Printf("学生名=%v，年龄=%v，成绩=%v\n", stu.Name, stu.Age, stu.Score)
}

type Pupil struct {
	student //嵌入student匿名结构体
}

type Graduate struct {
	student
}

func (p *Pupil) testing()  {
	fmt.Println("小学生考试中......")
	p.Score = 100
}

func (p *Graduate) testing()  {
	fmt.Println("大学生考试中......")
	p.Score = 97
}

func main() {
	var pupil = &Pupil{}
	pupil.Name = "崔"
	pupil.Age = 8
	pupil.testing()
	pupil.ShowInfo()
}
````

### 匿名就近

`````go
package main

import "fmt"

type A struct {
	Name string
	age int
}

func (a *A) sayOk()  {
	fmt.Println("A sayOk ", a.Name)
}

func (a *A) hello()  {
	fmt.Println("a hello ", a.Name)
}

type B struct {
	A
	Name string
}

func (b B) sayOk()  {
	fmt.Println("B sayOk", b.Name)
}

func main() {
	var b B
	b.Name = "jack"
	b.A.Name = "aaaa"
	b.age = 100
	b.sayOk()
	b.hello()
	b.A.sayOk()
}
`````

### 多继承

````go
package main

import "fmt"

type A struct {
	Name string
	age  int
}

type B struct {
	Name  string
	Score float64
}

type C struct {
	A
	B
}

type D struct {
	a A //有名结构体
}

type Goods struct {
	name  string
	Price float64
}

type Brand struct {
	Name    string
	address string
}

type TV struct {
	Goods
	Brand
}

type TV2 struct {
	*Goods
	*Brand
}

func main() {
	var c C
	//c.Name = "xin" //有多个继承且同属性，但C本身有时，不出错
	c.A.Name = "xin"

	var d D
	d.a.Name = "bing"

	//嵌套结构体，直接赋值
	tv := TV{Goods{"xin", 0.12}, Brand{"ling", "北京"}}

	tv2 := TV{
		Goods{
			name:  "xin",
			Price: 0.12,
		},
		Brand{
			Name:    "ling",
			address: "北京",
		},
	}

	fmt.Println(tv)
	fmt.Println(tv2)

	//会报错
	tv3 := TV2{&Goods{"xin", 0.12}, &Brand{"ling", "北京"}}
	fmt.Println(tv3)
	fmt.Println("tv3", *tv3.Goods)
}
````



## 接口























