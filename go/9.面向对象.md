# oop（结构体）

* 值拷贝

## 快速入门

````go
package main // 打包

import (  // 引入包
	"fmt"
)

type Cat struct {
	Name string
	Age int
	Color string
}

func main()  {
	var cat1 Cat
	fmt.Println(cat1)
	cat1.Name = "崔"
	cat1.Age = 12
	cat1.Color = "红"
	fmt.Println(cat1)
}
````

## 创建结构体二、三、四

````go
package main // 打包

import (  // 引入包
	"fmt"
)

type Person struct{
	Name string
	Age int
}

func main() {
	//方式一
	p1 := Person{}
	p1.Name = "崔"
	p1.Age = 20
	fmt.Println(p1)
	//方式二
	p2 := Person{"学", 21}
	fmt.Println(p2)
	//方式三
	var p3 *Person = new(Person) //p3是一个指针
	(*p3).Name = "智" //也可以 p3.Name = "smith"  底层做了处理
	(*p3).Age = 30
	fmt.Println(p3)
	//方式四
	var person *Person = &Person{"mary", 21}
	// var person *Person = &Person{}
	(*person).Name = "xiao"
	person.Age = 120
	fmt.Println(person)
}
````

## 使用细节

1. 结构体所有字段在内存中是连续的

   `````go
   package main // 打包

   import (  // 引入包
   	"fmt"
   )

   type Point struct {
   	x int
   	y int
   }

   type Rect struct {
   	leftUp, rightDown Point
   }

   type Rect2 struct {
   	leftUp, rightDown *Point
   }

   func main() {
       r1 := Rect{Point{1, 2}, Point{3, 4}}
       fmt.Printf("r1.leftUp.x=%p \n", &r1.leftUp.x)
       fmt.Printf("r1.leftUp.y=%p \n", &r1.leftUp.y)
       fmt.Printf("r1.rightDown.x=%p \n", &r1.rightDown.x)
       fmt.Printf("r1.rightDown.y=%p \n", &r1.rightDown.y)
       r2 := Rect2{&Point{10,20}, &Point{30, 40}}
       fmt.Printf("r2.leftUp=%p \n", &r2.leftUp)
       fmt.Printf("r2.rightDown=%p \n", &r2.rightDown)
       fmt.Printf("r2.leftUp=%p \n", r2.leftUp)
       fmt.Printf("r2.rightDown=%p \n", r2.rightDown)
   }

   // r1.leftUp.x=0xc00000a460
   // r1.leftUp.y=0xc00000a468
   // r1.rightDown.x=0xc00000a470
   // r1.rightDown.y=0xc00000a478
   // r2.leftUp=0xc0000321f0
   // r2.rightDown=0xc0000321f8
   // r2.leftUp=0xc0000120c0
   // r2.rightDown=0xc0000120d0
   `````

2. 结构体之间的转换需要完全相同

   ````go
   package main // 打包	

   import (  // 引入包
   	"fmt"
   )

   type A struct {
   	Num int
   }

   type B struct {
   	Num int
   }

   func main() {
     var a A
     var b B
     //a = b  //不可以
     a = A(b) //强转可以
     fmt.Println(a, b)
   }
   ````

3. 结构体进行type重新定义（相当于取别名），Golang认为是新的数据类型，当相互可以强转

   ````go
   package main // 打包

      import (  // 引入包
      	"fmt"
      )

      type Student struct {
      	Name string
      	Age int
      }

      type Stu Student

      func main() {
      	var stu1 Student
      	var stu2 Stu
      	// stu2 = stu1
      	stu2 = Stu(stu1) // { 0} { 0}
      	fmt.Println(stu1, stu2)
      }
   ````

   

   *******

   `````go
   package main // 打包

   import (  // 引入包
   	"fmt"
   )

   type integer int

   func main() {
     var i integer = 10
     var j int = 20
     j = i //报错
     fmt.Println(i, j)
   }
   `````

   

4. struct上的每个字段可以写上一个tag，此tag通过反射机制获取，常用来序列化和反序列化

   `````go
   package main // 打包

   import (  // 引入包
   	"fmt"
   	"encoding/json"
   )

   type Monster struct{
   	Name string `json:"name"`
   	Age int `json:"age"`
   	Skill string `json:"skill"`
   }

   func main() {
   	monster := Monster{"牛魔王", 1090, "芭蕉扇"}

   	//序列化
   	jsonStr, err := json.Marshal(monster)
   	if err!=nil{
   		fmt.Println("序列化错误")
   	}
   	fmt.Println(jsonStr)
   	fmt.Println(string(jsonStr)) //{"name":"牛魔王","age":1090,"skill":"芭蕉扇"}
   	// fmt.Println(jsonStr)
   }
   `````

   


## 方法

````go
package main // 打包

import (  // 引入包
	"fmt"
)

type Person struct {
	Name string
}

//为Person结构体绑定一个方法
func (a Person) test()  {
	a.Name = "1212"
	fmt.Println(a.Name)
}

func main() {
	var p Person
	p.Name = "haha"
	p.test() // 调用方法
	fmt.Println(p.Name)
}
````

### 方法的调用和执行过程

*  结构体是值拷贝
* 变量参数若为值类型进行值拷贝，引用类型进行地址拷贝





