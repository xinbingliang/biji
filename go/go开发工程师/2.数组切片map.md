# 数组切片map

## 数组

* 具有相同类型的一组长度固定的数据项序列，**数组长度也是数组类型的一部分，所以[5]int和[10]int是属于不同类型的 **
* 数字数据在内存中的分布是连续的
* 进行值拷贝传递
* 数组传递到函数，执行值传递，是CPU密集型操作

### 定义

````go
package main

import "fmt"

func main() {
	var arrVar0 [10]int
	arrVar0[0] = 1
	arrVar0[3] = 12
	fmt.Println(arrVar0)

	var arrVar1 [5]int = [5]int{1, 2, 3}
	var arrVar2 = [5]int{110, 34, 3, 12, 1212}
	fmt.Println(arrVar1)
	fmt.Println(arrVar2)

	arrVar3 := [...]int{1, 2, 3, 4}
	fmt.Println(arrVar3)

	//指定索引下标
	arrVar4 := [...]int{1: 200, 3:500}
	fmt.Println(arrVar4)
}
````

### 多维数组

`````go
//多维数组
var arrVar5 [4][2]int
fmt.Println(arrVar5)

arrVar6 := [4][2]int{{10, 11}, {11, 12}}
fmt.Println(arrVar6)

arrVar7 := [4][2]int{1:{10, 99}, 2:{9, 8}}
fmt.Println(arrVar7)
`````

### 遍历和值传递

````go
arrVar8 := [3]string{"崔学智", "幸运", "golang"}
arrVar9 := arrVar8
for key,val := range arrVar8 {
	fmt.Printf("arrVar8[%d]=%v, 地址=%p\n", key, val, &arrVar8[key])
}
fmt.Println("值传递后：") //其实是将数据复制到内存中的另外的一个位置
for key,val := range arrVar9 {
	fmt.Printf("arrVar8[%d]=%v, 地址=%p\n", key, val, &arrVar9[key])
}
````

````go
arrVar8 := [3]string{"崔学智", "幸运", "golang"}
for i := 0; i < len(arrVar8); i++ {
	fmt.Printf("arrVar8[%d]=%v, 地址=%p\n", i, arrVar8[i], &arrVar8[i])
}
````

## 切片

* 自动增长，动态数组
* 底层指向的是数组
* 容量改变后，对应的维护底层的数组也会改变
* 内存当中是连续的存储空间
* 引用类型

### 作用

* 在函数当中传递切片时，当数据类型数据较大时，使用切片可以有效减少内存占用，提高程序执行效率
* 从数据库表中读取商品信息时，用到map切片，每一个map看成一个整体

### 定义

`````go
package main

import "fmt"

func main() {
	arrVar := [...]int{12, 21, 23, 55, 98, 2}
	var sliceArrVar []int
	sliceArrVar = arrVar[:] //定义一个切片去引用数组，这种情况默认长度和容量一致
	fmt.Println(sliceArrVar)

	fmt.Println("数组的地址显示：")
	for i := 0; i < len(arrVar); i++ {
		fmt.Printf("arrVar[%d]=%d, 地址=%p\n", i, arrVar[i], &arrVar[i])
	}

	fmt.Println("切片地址显示：")
	for i := 0; i < len(sliceArrVar); i++ {
		fmt.Printf("arrVar[%d]=%d, 地址=%p\n", i, sliceArrVar[i], &sliceArrVar[i])
	}

	sliceArrVar[1] = 100000
	//引用赋值
	fmt.Println(arrVar)
	fmt.Println(sliceArrVar)
}
`````

### 使用make

`````go
sliceVar1 := make([]int, 5)
fmt.Printf("sliceVar1的长度=%d,容量=%d,\n切片指向的底层数组的地址=%p,切片自己的地址=%p\n", len(sliceVar1), cap(sliceVar1), sliceVar1, &sliceVar1)
`````

### 遍历

`````go
package main

import "fmt"

func main() {
	arrVar := [...]int{12, 21, 23, 55, 98, 2}
	var sliceArrVar []int
	sliceArrVar = arrVar[:] //定义一个切片去引用数组，这种情况默认长度和容量一致
	fmt.Println(sliceArrVar)

	for i:=0;i<len(sliceArrVar);i++{
		fmt.Printf("sliceArrVar[%d]=%d,地址=%p\n", i, sliceArrVar[i], &sliceArrVar[i])
	}

	for key, val := range sliceArrVar{
		fmt.Println(key, val)
	}
}
`````

### 追加

````go
package main

import "fmt"

func main() {
	arrVar := [...]int{12, 21, 23, 55, 98, 2}
	var sliceArrVar []int
	sliceArrVar = arrVar[:] //定义一个切片去引用数组，这种情况默认长度和容量一致
	fmt.Println(sliceArrVar)

	fmt.Printf("第一次追加sliceVariables3的长度=%d,容量=%d,\n切片指向的底层数组的地址=%p,切片自己的地址=%p\n",len(sliceArrVar),cap(sliceArrVar),sliceArrVar,&sliceArrVar)
	sliceArrVar = append(sliceArrVar, 100)
	fmt.Printf("第一次追加sliceVariables3的长度=%d,容量=%d,\n切片指向的底层数组的地址=%p,切片自己的地址=%p\n",len(sliceArrVar),cap(sliceArrVar),sliceArrVar,&sliceArrVar)
	//添加后切片地址不会变化，但指向的数组会变化，数组发生了重建
}
````

### 拷贝

`````go
package main

import "fmt"

func main() {
	// 定义源切片
	sliceVar := []int{1,2,3,4,5}
	// 定义目标切片
	sliceVar2 := make([]int, 10)
	copy(sliceVar2, sliceVar)
	// 拷贝的数量以两个切片中最小切片的长度为准
	fmt.Println(sliceVar)
	fmt.Println(sliceVar2)
}
`````

### 函数参数传递

切片做为参数传递给函数的意义重大，同数组，当传递较大的数组切片时可以有效的提升cpu执行效率

```go
func changeSlice(slice []int) {
   slice[0] = 100
}

//切片是引用类型
fmt.Println(sliceVariables5)
changeSlice(sliceVariables5)
fmt.Println(sliceVariables5)
```

## map







