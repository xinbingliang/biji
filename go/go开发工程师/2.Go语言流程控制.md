# Go语言流程控制

````
	/*
	流程控制 条件控制：if eles else if
	选择控制 switch case select fallthrough
	循环控制 for for range
	跳转控制 goto
		break continue 
	*/
````

## 条件控制

### comma-ok

````go
if fileHandle,err := os.Open("hello.txt");err != nil {
    //null
    fmt.Println(fileHandle)
    fmt.Println(err.Error())
} else {
  	fmt.Println("获取文件成功")
}
````

## 选择控制

### swith

#### 穿透

````go
switch switchVariables := 100; {
    case switchVariables >90:
        fmt.Println("成绩优秀")
        fallthrough
    case switchVariables>80:
        fmt.Println("成绩良好")
        fallthrough
    case switchVariables >=60:
        fmt.Println("成绩合格")
    default:
        fmt.Println("成绩不及格")
    }
````

## 循环控制

### goto

````go
package main

import "fmt"

func gotoFunc() {
	variables := 0
GOTO:
	fmt.Println(variables)
	variables++
	if variables < 100 {
		goto GOTO
	}
}

func main() {
	gotoFunc()
}
````

### break+标签

````go
package main

import "fmt"

func main() {
FORBREAK:
	for outerIndex := 0; outerIndex < 10; outerIndex++ {
		for innerIndex := 0; innerIndex < 6; innerIndex++ {
			fmt.Println(outerIndex, innerIndex)
			break FORBREAK
		}
	}

	fmt.Println("结束")
}
````

### continue+标签

````go
package main

import "fmt"

func main() {
//continue+标签，忽略当前循环剩余的代码，跳转转到某个标签
FORCONTINUE:
	for outerIndex := 0; outerIndex < 3; outerIndex++ {
		for innerIndex := 0; innerIndex < 2; innerIndex++ {
			fmt.Println(outerIndex, innerIndex)
			continue FORCONTINUE
			fmt.Println("这里是内层循环剩余的代码")
		}
	}
	fmt.Println("结束")
}
````

## 包

### 安装第三方包

* `go env`
* `go get`

### 构建包

* `go install`

## 函数

###  不定参数



## 递归函数、匿名函数、闭包
## 闭包、匿名函数补充、defer、函数重载、函数作为值类型
## 函数作为值、函数作为类型、init函数、main()函数、引用类型与值类型区别

