# 结构体

## 定义

### 自定义类型的方式1

````go
package main

import "fmt"

func main() {
	type structVariables struct {}

	type integer int
	var intVariables int
	var integerVariables integer

	//intVariables = integerVariables ////基于一种类型去创建另一种类型，被认为是两种不同的类型

	intVariables = int(integerVariables)
	fmt.Println(intVariables, integerVariables)
}
````

### 自定义类型的方式2

`````go
type userinfo struct {
    name string
    age int
    height float32
    eduschool string
    hobby []string
    moreinfo map[string]interface{}
}

//使用
var bobo userinfo
bobo.name = "波哥"
bobo.age = 18
bobo.height = 181
bobo.eduschool = "北京邮电大学"
bobo.hobby = []string{"coding","运动","旅行"}
bobo.moreinfo = map[string]interface{}{
    "work":"百度",
    "duty":"产品狗",
}
`````

### 自定义类型的方式3

`````go
package main

import "fmt"

type userinfo struct {
	name      string
	age       int
	height    float32
	eduschool string
	hobby     []string
	moreinfo  map[string]interface{}
}

func main() {
	huge := userinfo{
		eduschool: "北京电影学院",
		hobby:     []string{"拍电影","唱歌","旅行"},
		moreinfo: map[string]interface{}{
			"role":"演员",
			"earnmoney":300000,
		},
		name:      "胡哥",
		age:       28,
		height:    188,
	}
	fmt.Println(huge)
}
`````

`````go
xiaoge := userinfo{"小哥", 12, 120, "小学", []string{"学习", "玩", "打游戏"}, map[string]interface{}{"年级": "六年级"}}
fmt.Printf("xiaoge=%v\n", xiaoge)
`````

### 自定义类型的方式3 new

使用new new(int),new(string),new(T) 返回结构体指针

`````go
package main

import "fmt"

type userinfo struct {
	name      string
	age       int
	height    float32
	eduschool string
	hobby     []string
	moreinfo  map[string]interface{}
}

func main() {
	var xiaoming *userinfo
	xiaoming = new(userinfo)
	(*xiaoming).name = "xin"
	(*xiaoming).age = 12
	(*xiaoming).eduschool = "小学"
	//xiaoming->(*xiaoming) go语言编译器自动转换
	xiaoming.hobby = []string{"玩", "学习"}
	fmt.Println(xiaoming) //&{xin 12 0 小学 [玩 学习] map[]}
}
`````

### 结构体的使用方式4 &地址符，同样是返回的结构体指针

`````go
package main

import "fmt"

type userinfo struct {
	name      string
	age       int
	height    float32
	eduschool string
	hobby     []string
	moreinfo  map[string]interface{}
}

func main() {
	var xiaoming *userinfo = &userinfo{"小红", 12, 120, "小学", []string{"学习", "玩", "打游戏"}, map[string]interface{}{"年级": "五年级"}}
	fmt.Println(xiaoming)
}
`````

## 注意

1. 结构体是值类型

   ````go
   package main

   import "fmt"

   type userinfo struct {
   	name      string
   	age       int
   	height    float32
   	eduschool string
   	hobby     []string
   	moreinfo  map[string]interface{}
   }

   func main() {
   	user1 := userinfo{
   		name:      "user1",
   		age:       0,
   		height:    0,
   		eduschool: "",
   		hobby:     nil,
   		moreinfo:  nil,
   	}
   	user2 := user1
   	fmt.Printf("user1地址%p, user2地址%p\n", &user1, &user2) //user1地址0xc00003e050, user2地址0xc00003e0a0
   }
   ````

2. 结构体之间可以转换，前提条件：具有相同的字段（个数，类型，名称)

3. 结构体可以做为另一个结构体字段的类型

## 结构体可以做为另一个结构体字段的类型

```go
package main

import "fmt"

type userinfo struct {
	name      string
	age       int
	height    float32
	eduschool string
	hobby     []string
	moreinfo  map[string]interface{}
}

type Integer int

type role struct {
	user          userinfo
	authorization Integer //1=超级管理员，2=管理员，3=普通用户
}

func main() {
	superadmin := role{
		user: userinfo{
			name:      "超级管理员",
			age:       0,
			height:    0,
			eduschool: "",
			hobby:     nil,
			moreinfo:  nil,
		},
		authorization: 1,
	}
	admin := role{
		user: userinfo{
			name:      "管理员",
			age:       0,
			height:    0,
			eduschool: "",
			hobby:     nil,
			moreinfo:  nil,
		},
		authorization: 2,
	}
	fmt.Println(superadmin, admin)
}
```

## OOP

* 封装：对外暴露公开的接口，增强安全，简化编程，
* 继承：子类继承父类，自动拥有父类的属性和方法
* 多态：通过接口来实现 
  * 继承
  * 重写
  * 父类引用指向子类对象



