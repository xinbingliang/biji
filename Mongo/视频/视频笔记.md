# 视频笔记

* 文档数据库(`Bson`->即`json`的二进制化)
* 内部引擎使用`javascript`
* mongo文档型数据库没有特定结构

## 安装

* 2.4.8
* [中文社区文档](http://docs.mongoing.com/manual-zh/)

## 文件和作用

* bsondump.exe 导出bson结构
* mongo.exe 客户端
* mongod.exe 服务端
* mongodump.exe 整体数据库导出
* mongoexport.exe 导出人类易读json或csv
* mongofiles.exe 
* mongoimport.exe
* mongooplog.exe
* mongoperf.exe
* mongorestore.exe 数据库整体导入
* mongos.exe 路由器，集群时使用
* mongostat.exe 
* mongotop.exe 

## 启动

* mongod --dbpath 数据存放位置 --logpath 日志存放位置/xxx.log --fork  --port 27017
* --fork 后台进程
* --smallfiles 以最小化启动

## 命令操作

* show dbs; 查看库
* use dbsName; 使用一个库/或创建一个库
* show collections; 查看表
* db.createCollection('文档名称');创建表(实际上没有显示声明创建的必要)

### 增

* db.test.insert({"name":"辛丙亮","age":"24"}); 添加一条文档
* db.test.insert({"_id": 2, "name":"么么哒","age":"24"}); 指定id不让表默认生成id

### 删

* db.collectionName.drop(); 删除一个表
* db.dropDatabase(); 删除库
* db.test.remove({_id:2}) 删除一个记录/没有条件可以清空数据
* db.test.remove({_id:2, true}) 删除匹配到的第一行

### 改

- $inc 增长
- $rename  重命名列
- $setOnlnsert 当Upsert时，设置字段的值
- $set 设置字段的新值
- $unset 删除指定的列



*  db.test.update({sn:'002'}, {name:'辛丙亮'}) 将整个文档替换
*  db.test.update({sn:'003'}, {$set:{name:'辛丙亮'}}) 修改一个字段

### 查

* db.test.find(); 查询数据

* db.collection.find(查询表达式,查寻的列)

  ```
  db.test.find({}) 所有文档的所有的列
  db.test.find({}, {gender:1}) 所有gender为1 的属性
  db.test.find({}, {gender:1, _id: 0}) 所有gender为1 的属性并不显示id
  db.test.find({gender:'male'}, {name:1,_id: 0}) 所有male的姓名
  ```

## CURD



## 比较运算符

* $gt    >
* $gte     >=
* $in    in
* $lt    <
* $lte    <=
* $ne    !=
* $nin    not in
* $all    无对应项,指数组所有单元匹配

## 逻辑运算符

* $or    or
* $and     and
* $not    not
* $nor    无对应项，指所有列举条件都不成功则为"真"

## 元素运算符

* $exists    某列存在则为真
* $mod    满足某求余条件者为真
* $type    数据为某类型则为真

## Javascript运算符

* $where js表达式为真则为真
* $regex    正则表达式匹配则为真
* $inc 增长
* $rename  重命名列
* $setOnlnsert 当Upsert时，设置字段的值
* $set 设置字段的新值
* $unset 删除指定的列


````
db.test.update(
{name: 'wukong'},	查询表达式
$set: {name: 'dzsf'}, 修改值  后面统称赋值表达式
$unset: {jingu: 1}, 删除字段
$rename: {sex: 'gender'}, 重命名
$inc: {age:16} +16
)
````

option：

`{upsert: true/false, multi: true/false}`

`Upsert` 指没有匹配的行就插入该行

`multi` 是指修改多行

````
db.test.update({gender: 'm'}, {$set: {
  gender: 'male'
}},{multi: true})
````

## 深入查询表达式

### mysql->mongo

* json_encode()

### 例子

1. 最简单的查询表达式

   ````
   {filed: value} 是指查询field列的值为value的文档
   ````

2. $ne   !=查询表达式

   ````
   {field: {$nq: value}} 查filed列的值不等于value的文档
   db.test.find({cat_id: {$nq: 3}}, {cat_id:1, goods_name:1, _id:0}) 指定查询的字段
   ````

3. $nin   not in

   ````
   db.test.find({cat_id: {$in: [4, 11]}}, {catid:1, goods_name: 1, _id: 0})
   ````

4. $gt 大于某个值

   ````
   db.test.find({shop_price: {$gt: 3000}}, {goods_name: 1, shop_price: 1, _id: 0})
   ````

5. $lte 低于或等于

   ````
   db.test.find({shop_price: {$lte: 100}}, {goods_name:1, shop_price: 1})
   ````

6. $all 

   ````
   语法：{field: {$all: [v1, v2]}}
   是指取出field列是一个数组，且至少包含v1、v2值
   ````

7. or 或

   ````
   db.test.find({$and; [{price: {$gt: 100}, {$price: {$lt: 500}}}]})
   ````

8. and

   ```
   db.test.find({$and:[{shop_price:{$gte: 100}}, {shop_price: {$lte: 500}}], {goods_name: 1, shop_price: 1, _id: 0})
   ```

9. 实现且

   ```
   db.test.find($and:[{cat_id: {$ne: 3}}, {cat_id: {$ne: 11}}], {$goods_name: 1, cat_id: 1})
   db.test.find({cat_id: {$nin: [3, 11]}}, {goods_name: 1, cat_id: 0})
   db.test.find({$nor:[{cat_id:3}, {cat_id:11}]}, {goods_name: 1, cat_id: 1})
   ```

10. not

  ```

  ```

11. $mod 满足某求余条件为真

    ````
    db.goods.find({goods_id: {$mod: [5, 0]}}, {}) 	goods_id%5 = 0
    ````

21. $type 数据为某类型则为真(严格存储类型)

    ```
    db.test.find({age; {$type: 2}}) //字符串类型
    ```

31. $all 指定内容必须有

    ````
    db.stu.find({hobby: {$all: ['b', 'c']}})
    ````

41. $exists 文档有没有某一列，存在就取出

    ````
    语法：{field: {$exists: 1}}
    作用:查询出含有field字段的文档
    db.stu.find({age: {$exists:1}})
    ````

51. $nor 即不是也不是

    ````
    db.test.find({$nor:[{cat_id:3}, {cat_id:11}]}, {goods_name: 1, cat_id: 1})
    ````

61. 用where 表达式来查询

    ```
    db.test.find({$where: 'this.price>5000'})
    ```

71. $regex 正则表达式匹配则为真

    ````
    db.test.find({goods_name: {$regex: /^诺基亚.*/}})
    ````

## 游标操作

```
for (var i = 0; i< 10000;i++){
  db.bar.insert({_id; i+1, title: 'Hello'});
};
```

游标：通俗的说，不是查询结果而是查询的返回资源，通过这个接口逐条读取

### 游标的声明

````
var cursor = db.collectionName.find(query, projection);
cursor.hasNext(); 判断游标是否到达尽头
cursor.Next(); 取出游标的下一个单元

printjson(cursor.next()); 打印出一行
````

### 使用while循环游标

```javascript
var mycursor = db.test.find({_id:{$lte: 5}})
while (mycursor.hasnext()){	//注意判断标记
  printjson(mycursor.next());
}
```

### 迭代函数

允许自定义回调函数来逐个处理每个单元

cursor.forEach(回调函数)

```javascript
var gettitle = function(obj){
  print(obj.goods_name);
}

var cursor = db.goods.find();
cursor.forEach(gettitle);
```

### 分页时使用游标

- 查到10000行，跳过100页，取10行

```
var mycursor = db.bar.find().skip(9995);
mycursor.forEach(function (obj){
  printjson(obj)
})
```

- 查询第901页，每页10行

```
var mycursor = db.bar.find().skip(9000).limit(10);
mycursor.forEach(function (obj){ printjson(obj)})
```

- 不使用游标直接查询

```
db.test.find().skip(9000).limit(5);
```

### 一次性得到游标获得的数据

```
var cursor = db.test.find()
printjson(cursor.toArray());//看到所有的行
printjson(cursor.toArray([2])) //看到第2个
```

**不要随意使用toArray()**

## 索引

1. 索引是提高查询速度，降低写入速度，权衡常用的查询字段，不必在太多列上建索引
2. 在`mongodb`中索引可以按字段升序/降序来创建，便于排序。
3. 默认是使用btree来组织索引文件，2.4版本以后，也允许建立hash

### explain()

查看查询计划

```
db.test.find({sn: 99}).explain();

//结果
"cursor": "BasicCursor", 说明没有索引发挥作用
"nscannmedObjects": 1000 理论上要扫面多少行
```

使用while循环游标

```javascript
var mycursor = db.test.find({_id:{$lte: 5}})
while (mycursor.hasnext()){	//注意判断标记
  printjson(mycursor.next());
}
```

### 迭代函数

允许自定义回调函数来逐个处理每个单元

cursor.forEach(回调函数)

```javascript
var gettitle = function(obj){
  print(obj.goods_name);
}

var cursor = db.goods.find();
cursor.forEach(gettitle);
```

### 分页时使用游标

- 查到10000行，跳过100页，取10行

```
var mycursor = db.bar.find().skip(9995);
mycursor.forEach(function (obj){
  printjson(obj)
})
```

- 查询第901页，每页10行

```
var mycursor = db.bar.find().skip(9000).limit(10);
mycursor.forEach(function (obj){ printjson(obj)})
```

- 不使用游标直接查询

```
db.test.find().skip(9000).limit(5);
```

### 一次性得到游标获得的数据

```
var cursor = db.test.find()
printjson(cursor.toArray());//看到所有的行
printjson(cursor.toArray([2])) //看到第2个
```

**不要随意使用toArray()**

## 索引

1. 索引是提高查询速度，降低写入速度，权衡常用的查询字段，不必在太多列上建索引
2. 在`mongodb`中索引可以按字段升序/降序来创建，便于排序。
3. 默认是使用btree来组织索引文件，2.4版本以后，也允许建立hash

### explain()

查看查询计划

```
db.test.find({sn: 99}).explain();

//结果
"cursor": "BasicCursor", 说明没有索引发挥作用
"nscannmedObjects": 1000 理论上要扫面多少行
```

### 查看索引的状态

- db.collection.getIndexs()

### 创建普通单例索引

- db.collection.ensureIndex({field: 1/-1})

### 创建多列索引

- db.collection.ensureIndex({field1:1/-1. field2:1/-1})

### 创建子文档索引

- db.collection.ensureIndex({filed.subfield:1/-1})

```
db.test.ensureIndex({'spc.area': 1})
```

### 子文档查询

```
db.test.find({'obj.name': 'xin'})
```

### 创建唯一索引

- db.collection.ensureIndex({filed.subfield:1/-1}, {unique: true})

### 删除单个索引

- db.collection.dropIndex({filed: 1/ -1}) 要指定+-

### 删除所有索引

- db.collection.dropIndexes()

### 索引的性质

1. 普通索引

2. 唯一索引

3. 稀疏索引

   如果针对field做索引，针对不含field的列的文档，将不建立索引。与之相对的普通索引，会把该文档的field列的值认为NULL，并建立索引。普通索引为空返回null，稀疏索引直接忽略，普通索引能通过null查到，而稀疏索引无法查到

   ```
   db.collection.ensureIndex({field: 1/-1}, {sparse: true})
   ```

4. 哈希索引


范围和顺序数据不适合使用。

````
db.test.ensureIndex([email: 'hashed'])
````

### 重建索引

一个表经过多次修改后导致表文件产生空洞，索引也是一样

通过索引重建提升索引效率，类似mysql中的optimize table，减少索引文件碎片

```
db.test.reIndex()
```

## 用户管理


































