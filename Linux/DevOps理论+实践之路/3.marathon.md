# marathon

负责长任务处理的Framework，即服务调度框架

* `Application` 表示一个批处理，或启动了一个docker就是一个Application
* `Application definition` 表示一个长服务的定义，规定一个Application启动和运行时的所有行为
* `Application instance` 一个应用程序实例，称作一个Mesos的task
* `Deployments` 每次定义修改和提交
* `Application Group` 将应用程序组织成一棵树的结构，Gropu即树枝，Application称为叶子

## 安装

[安装文档位置](https://mesosphere.github.io/marathon/docs/) 选择mesos主节点进行安装

`````
MESOS_NATIVE_JAVA_LIBRARY=/usr/local/lib/libmesos.so ./marathon --master zk://192.168.232.191:2181/mesos,192.168.232.192:2181/mesos,192.168.232.193:2181/mesos --zk zk://192.168.232.191:2181/marathon,192.168.232.192:2181/marathon,192.168.232.193:2181/marathon
`````

## 建立第一个应用程序

`````
{
  "id":"ch1", # 应用程序的唯一标识
  "cmd":"while [true];do echo 'Hello Marathon'; sleep 5; done", # 应用执行的内容
  "cpus": 0.1, # 分配的CPU
  "mem": 10.0, # 分配的内存，单位为m
  "instances":1 # 启用的实例数量
}

{
    "id": "basic-0", 
    "cmd": "while [ true ] ; do echo 'Hello Marathon' ; sleep 5 ; done",
    "cpus": 0.1,
    "mem": 10.0,
    "instances": 1
}
`````

### 部署方式

#### API方式

`````
curl -X POST http://192.168.232.191:8080/v2/apps -d @ch1.json -H "Content-type: application/json"
`````

#### 图形界面方式

* 数据存储在mesos的工作目录中

### 应用生命周期

* Running：应用程序被成功的运行
* Deploying：应用程序的每一次改变操作没有完成之前，我们应用都属于一个Deploying的状态
* Suspended：被这个应用的所有正在运行的实例杀掉，并把这个应用定义的实例数量减为0，这时这个应用只保留了定义，并没有正在运行的实例
* Wating：应用程序在等待mesos进行一下资源的分配等等操作
* Delayed：在很短时间内，应用程序失败过多就会被变成delayed marathon会暂停这个部署或者稍后进行重试

### 应用操作

* Scale：为某个应用增加或减少指定数量的实例
* Restart：重启应用，可以称为Rolling upgrade，它先创建一个新的实例，然后把老的实例杀死
* Suspend：把这个应用的所有正在运行的实例杀掉，并把这个应用定义的实例的数量减为0，这时这个应用只保留了定义，并没有正在运行的实例
* Destroy：把这个应用的实例和定义的全部删除，它不可恢复

## Marathon API接口分类

### 接口分类

* app 应用类
* deployments 部署类
* tasks 任务类
* pods 
* groups类

### 使用flask进行接口调用

````python
# -*- coding:utf-8 -*-
import json

import requests
from flask import Flask

__Author__ = "xinneirong"
__Email__ = "xinneirong@gmail.com"
__Time__ = "2019/9/7 16:42"

app = Flask(__name__)

headers = {
    'Content-type': 'application/json'
}

@app.route('/')
def index():
    ip = 'http://192.168.232.193:8080/'
    path = 'v2/info'
    url = ip+path
    print(url)
    r = requests.get(url, headers=headers)
    print(json.dumps(r.json()), indent=4)
    return 'ok'


if __name__ == '__main__':
    app.run(host='0.0.0.0', port='5000', debug=True)
````

### marathon和docker

* angent节点已经安装docker

* 使用案例

  ````
  {
    "id": "basic-3", # 唯一标识符
    "cmd": "python3 -m http.server 8080", # 容器运行的命令
    "cpus": 0.5, # 分配的CPU
    "mem": 32.0, # 分配的内存
    "networks": [ { "mode": "container/bridge" } ], # 容器的网络配置
    "container": {
      "type": "DOCKER", # 使用的容器类型
      "docker": {
        "image": "python:3"
      },
      "portMappings": [ 
        { "containerPort": 8080, "hostPort": 0 } # 配置端口映射
      ]
    }
  }
  ````

* 使用`/v2/apps`创建应用

* 端口配置

  `````
  "portMappings": [ 
  	{ 
        "containerPort": 8080,
        "hostPort": 0,
        "servicePort": 10001,
        "protocol": "tcp"
      } # 配置端口映射
  ]
  `````

  * `containerPort` 容器内部需要对外映射的端口
  * `hostPort` 容器映射到宿主机的端口，0表示使用随机的端口，分布式任务中很常见，避免端口冲突
  * `servicePort` APP的服务端口
  * `protocol` 协议

## CI CD

* CI：持续集成，代码编写->代码审查->单元测试->项目打包
* 使用一台服务器安装gitlab
* 使用一台服务器安装docker-registry
* 测试发布流程

## 健康检查

[健康检查文档](https://mesosphere.github.io/marathon/docs/health-checks.html)

`````
{
  "path": "/", # 健康检查路径
  "portIndex": 0,
  "protocol": "HTTP", # 请求方式
  "gracePeriodSeconds": 300, # 忽略时间，应用启动时忽略
  "intervalSeconds": 60, # 间隔时间，设置健康检查的间隔时间
  "timeoutSeconds": 20, # 超时时间
  "maxConsecutiveFailures": 3, # 最大失败次数
  "ignoreHttp1xx": false # 设置忽略的HTTP状态
}
`````

1. 故障重启，高可用
2. 建议在应用中埋设健康检查点，对所有需要检查项进行检查（含：数据库检查、中间件检查、其他组件检查）

## 动态扩容

1. 根据单容器并发值确定扩容数量
2. 动态扩展容器数量（秒级）
3. 活动结束资源回收

## 应用部署

### 依赖

### 强制部署

## 滚动升级

1. 删除部分旧版本实例，保留另外一部分的旧版本实例
2. 启动新版本的实例，健康检查通过
3. 删除剩下旧版本实例

````
minimumHealehCapacity == 0 在新实例启动前将旧实例全部删除，业务会产生一个中断
minimumHealehCapacity == 0~1 按比例缩容，并滚动部署，先更新部分，后更新剩余部分
1 使实例增加一倍，原实例先不发生变化，此刻消耗资源会翻倍
````







