# protobuf和grpc进阶

## 基本类型、默认值

* 当值不被传递时，使用默认值

* 数组的实现

  ```go
  message HelloReply {
      string message = 1;
      repeated int32 id = 2;
  }
  ```

* Python数组类型，不能先定义后赋值，可以使用数据拼接或append添加

## option go_package的作用

````
|-proto
|--common
|---stream
|----proto
````

````
//option go_package = ".;proto";
//option go_package = "common/stream/proto/v1";
option go_package = "../../common/stream/proto/v1";
````

## 当proto文件不同步的时候容易出现的问题

* 数据序列化用序列号，不是用变量名

## proto文件中引入其他的proto文件

````protobuf
// base.proto
syntax = "proto3";

//message Empty{}

message Pong{
  string id = 1;
}
````

````protobuf
// helloworld.proto
syntax = "proto3";
import "base.proto";

import "google/protobuf/empty.proto";

option go_package = ".;proto";

service Greeter {
    rpc SayHello (HelloRequest) returns (HelloReply);
    rpc Ping(google.protobuf.Empty) returns (Pong);
}
//将 sessionid放入 放入cookie中 http协议
message HelloRequest {
    string name = 1;
}

message HelloReply {
    string message = 1;
    repeated int32 id = 2;
}
````

````
from google.protobuf.empty_pb2 import Empty
````

## 嵌套的message对象

```protobuf
message HelloReply {
  string message = 1;
 
  message Result {
    string name = 1;
    string url = 2;
  }
}
```

```python
# 使用
result=HelloReply.Result()
```

## protobuf中的enum枚举类型

```protobuf
enum Gender{
  MALE = 0;
  FEMALE = 1;
}

message HelloReply {
  string message = 1;
  Gender sex = 2;

  message Result {
    string name = 1;
    string url = 2;
  }
}
```

```go
Gender_MALE
```

## map类型

````protobuf
message HelloRequest {
    string name = 1;
    map <string, string> mp = 2;
}
````

`````go
map[string]string {
  "name": "xin",
  "company": "哈哈",
}
`````

## 使用protobuf内置的timestamp类型

````protobuf
syntax = "proto3";
import "google/protobuf/timestamp.proto";
option go_package = ".;proto";

message HelloRequest {
    string name = 1;
    map <string, string> mp = 2;
    google.protobuf.Timestamp addTime = 3;
}
````

`````go
import (
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

{
  AddTime: timestamppb.New(time.Now())
}
`````

## grpc配合asyncio使用

* `pipenv install grpclib` 多安装

`````protobuf
syntax = "proto3";

service Greeter {
    rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
    string name = 1;
}

message HelloReply {
    string message = 1;
}
`````

* `python -m grpc_tools.protoc --python_out=. --grpclib_python_out=. -I. *.proto` 命令有变化

`````python
import asyncio

from grpclib.utils import graceful_exit
from grpclib.server import Server

# generated by protoc
from .hello_pb2 import HelloReply
from .hello_grpc import GreeterBase


class Greeter(GreeterBase):
    async def SayHello(self, stream):
        request = await stream.recv_message()
        message = f'Hello, {request.name}!'
        await stream.send_message(HelloReply(message=message))


async def main(*, host='127.0.0.1', port=50051):
    server = Server([Greeter()])
    # Note: graceful_exit isn't supported in Windows
    # with  graceful_exit([server]):
    await server.start(host, port)
    print(f'Serving on {host}:{port}')
    await server.wait_closed()


if __name__ == '__main__':
    asyncio.run(main())
`````

````python
import asyncio

from grpclib.client import Channel

# generated by protoc
from .helloworld_pb2 import HelloRequest, HelloReply
from .helloworld_grpc import GreeterStub

async def main():
    async with Channel('127.0.0.1', 50051) as channel:
        greeter = GreeterStub(channel)
        reply = await greeter.SayHello(HelloRequest(name='Dr. Strange'))
        print(reply.message)

if __name__ == '__main__':
    asyncio.run(main())
````

## grpc的metadata机制-go

`````go
 // 第一种方式
md := metadata.New(map[string]string{"key1":"val1","key2":"val2","key3":"val3"})
// 第二种方式,key不区分大小写，统一转换为小写
md := metadata.Pairs(
	"key1","val1",
	"key2","val2",
	"key3","val3"
	)
//新建一个有metadata的context
ctx := metadata.NewOutgoingContext(context.Background(), md)
//单向RPC
response, err := client.SomeRPC(ctx, someRequest)xxxxxxxxxx // 第一种方式md := metadata.New(map[string]string{"key1":"val1","key2":"val2","key3":"val3"})// 第二种方式,key不区分大小写，统一转换为小写md := metadata.Pairs(    "key1","val1",    "key2","val2",    "key3","val3"    )

`````

````
md, ok = metadata.FormIncomingContext(ctx)
````

`````go
//server.go
package main

import (
	"context"
	"fmt"
	"go_xin/grpc_go/proto"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	"net"
)

type Server struct{}

func (s *Server) SayHello(ctx context.Context, req *proto.HelloRequest) (*proto.HelloReply, error) {
	md , ok := metadata.FromIncomingContext(ctx)

	if ok {
		fmt.Println("get Error")
	}
	for key, val := range md{
		fmt.Println(key, val)
	}

	if name, ok := md["name"]; ok {
		fmt.Println(name)
	}

	return &proto.HelloReply{
		Message: "Hello " + req.Name,
	}, nil
}

func main() {
	//实例一个grpc的server
	g := grpc.NewServer()
	// 注册
	proto.RegisterGreeterServer(g, &Server{})
	// 启动
	lis, err := net.Listen("tcp", "0.0.0.0:1234")
	if err != nil {
		panic("failed to listen" + err.Error())
	}
	err = g.Serve(lis)
	if err != nil {
		panic("failed to start grpc:" + err.Error())
	}
}
`````

`````go
//client.go
package main

import (
	"context"
	"fmt"
	"go_xin/grpc_go/proto"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

func main() {
	conn, err := grpc.Dial("127.0.0.1:1234", grpc.WithInsecure()) //拨号
	if err != nil{
		panic(err)
	}
	defer conn.Close()

	c := proto.NewGreeterClient(conn)
	//md := metadata.Pairs("timestamp", time.Now().Format(timestampFormat))
	md := metadata.New(map[string]string{
		"name": "xin",
		"password": "12345678",
	})
	ctx := metadata.NewOutgoingContext(context.Background(), md)

	r, err := c.SayHello(ctx, &proto.HelloRequest{Name: "xin"})
	if err != nil{
		panic(err)
	}
	fmt.Println(r.Message)
}
`````

## python操作metada

`````protobuf
syntax = "proto3";
option go_package=".;proto";

// The greeting service definition.
service Greeter {
    //   Sends a greeting
    rpc SayHello (HelloRequest) returns (HelloReply) {
    }
}

// The request message containing the user's name.
message HelloRequest {
    string name = 1;
}

// The response message containing the greetings
message HelloReply {
    string message = 1;
}
`````

`````python 
# server.py
from __future__ import print_function
from concurrent import futures
import logging

import grpc

import helloworld_pb2
import helloworld_pb2_grpc


class Greeter(helloworld_pb2_grpc.GreeterServicer):

    def SayHello(self, request, context):
        for key, value in context.invocation_metadata():
            print('Received initial metadata: key=%s value=%s' % (key, value))

        return helloworld_pb2.HelloReply(message='Hello, %s!' % request.name)

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    helloworld_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)
    server.add_insecure_port('[::]:50051')
    server.start()
    server.wait_for_termination()

if __name__ == '__main__':
    logging.basicConfig()
    serve()
`````

`````python
from __future__ import print_function
import logging

import grpc

import helloworld_pb2
import helloworld_pb2_grpc


def run():
    # NOTE(gRPC Python Team): .close() is possible on a channel and should be
    # used in circumstances in which the with statement does not fit the needs
    # of the code.
    with grpc.insecure_channel('localhost:50051') as channel:
        stub = helloworld_pb2_grpc.GreeterStub(channel)
        response, call = stub.SayHello.with_call(
            helloworld_pb2.HelloRequest(name='you'),
            metadata=(
                ('name', 'bobby'),
                ('password','imooc')
            )

    print("Greeter client received: " + response.message)

if __name__ == '__main__':
    run()
`````



## grpc拦截器 - go



## python实现grpc的拦截器



## 通过拦截器和metadata实现grpc的auth认证



## grpc的验证器



## grpc中的错误处理



## grpc的超时机制





















