# rocketmq消息队列入门

## 安装

* 使用docker-compose

````
# /install/conf/broker.conf
brokerIP1=192.168.2.57
````

## 基本概念

* Producer:消息的发送者; 举例:发信者 
* Consumer:消息接收者; 举例:收信者 
* Broker:暂存和传输消息; 举例:邮局 
* NameServer:管理Broker; 举例:各个邮局的管理机构 
* Topic:区分消息的种类; 一个发送者可以发送消息给一个或者多个Topic; 一个消息的接收者可以订阅一个或者 多个Topic消息 
* MessageQueue:相当于是Topic的分区; 用于并行发送和接收消息

## 消息类型

### 按照发送的特点分

* 同步发送 

  1. 同步发送, 线程阻塞, 投递completes阻塞结束 

  2. 如果发送失败,会在默认的超时时间3秒内进行重试,最多重试2次 

  3. 投递completes不代表投递成功, 要check Send Result.send Status来判断是否投递成功| 

  4. Send Result里面有发送状态的枚举:Send Status, 同步的消息投递有一个状态返回值的

     `````
     SEND_OK, //只有这种才会停止重试
     FLUSH_DISK_TIMEOUT
     FLUSH_SLAVE_TIMEOUT
     SLAVE_NOT_AVAILABLE
     `````

* 异步发送 

  * 异步调用的话, 当前线程一定要等待异步线程回调结束再关闭producer啊, 因为是异步的, 不会阻塞, 提前关 闭producer会导致未回调链接就断开了 
  * 异步消息不retry, 投递失败回调on Exception() 方法, 只有同步消息才会retry, 源码参考 Default MQ Producer l mpl.class 
  * 异步发送一般用于链路耗时较长,对RT响应时间较为敏感的业务场景,例如用户视频上传后通知启动转码 服务,转码完成后通知推送转码结果等。

* 单向发送

  * 消息不可靠,性能高,只负责往服务器发送一条消息,不会重试也不关心是否发送成功 
  * 此方式发送消息的过程耗时非常短, 一般在微秒级别

### 按照使用功能特点分

* 普通消息(订阅) 
* 顺序消息 
* 延时消息 
* 事务消息 

##  分布式事务消息的优势



























