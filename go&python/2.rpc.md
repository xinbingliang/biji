#  rpc

远程过程调用

* Call ID的映射
* 序列化和反序列化
* 网络传输


## python默认RPC

### xml

`````python
from xmlrpc.server import SimpleXMLRPCServer

# 没有url的映射
# 没有编解码
class Calculate:
    def add(self, x, y):
        return x + y

    def multiply(self, x, y):
        return x * y

    def subtract(self, x, y):
        return abs(x - y)

    def divide(self, x, y):
        return x / y


obj = Calculate()
server = SimpleXMLRPCServer(("localhost", 8088))
# 将实例注册给rpc server
server.register_instance(obj)
print("Listening on port 8088")
server.serve_forever()
`````

````python
from xmlrpc import client

server = client.ServerProxy("http://localhost:8088")
print(server.add(2, 3))
````

1. 超时机制-重试

2. 限流 处于长时间可用的状态-高可用

3. 解耦

4. 负载均衡微服务-分布式应用的一种具体的体现

5. 序列化和反序列化数据压缩是否高效json这种数据格式已经非常的简单了 （这个序列化协议能将数据的压缩变得更小

   ）

6. 支持多语言

## go-rpc

````go
// server.go
package main

import (
	"net"
	"net/rpc"
)

type HelloService struct{}

func (s *HelloService) Hello(request string, reply *string) error {
	// 返回值是通过修改reply的值
	*reply = "Hello, " + request
	return nil
}

func main() {
	// 1. 实例化一个server
	listener, _ := net.Listen("tcp", ":1234") //启动一个tcp去监听
	// 2. 注册一个处理逻辑
	_ = rpc.RegisterName("HelloService", &HelloService{})
	// 3. 启动服务
	conn, _ := listener.Accept() // 新的连接进来使用套接字
	rpc.ServeConn(conn)
}
````

````go
//client.go
package main

import (
	"fmt"
	"net/rpc"
)

func main() {
	// 1. 建立连接
	client, err := rpc.Dial("tcp", "localhost:1234")
	if err != nil {
		panic("连接失败")
	}
	//var reply *string = new(string)
	var reply string
	err = client.Call("HelloService.Hello", "xin", &reply)
	if err != nil{
		panic("调用失败")
	}
	//fmt.Println(*reply)
	fmt.Println(reply)
}
````

### go-rpc-json

`````go
//server.go
package main

import (
	"net"
	"net/rpc"
	"net/rpc/jsonrpc"
)

type HelloService struct{}

func (s *HelloService) Hello(request string, reply *string) error {
	// 返回值是通过修改reply的值
	*reply = "Hello, " + request
	return nil
}

func main() {
	// 1. 实例化一个server
	listener, _ := net.Listen("tcp", ":1234") //启动一个tcp去监听
	// 2. 注册一个处理逻辑
	_ = rpc.RegisterName("HelloService", &HelloService{})
	// 3. 启动服务
	for {
		conn, _ := listener.Accept() // 新的连接进来使用套接字
		//rpc.ServeConn(conn)
		go rpc.ServeCodec(jsonrpc.NewServerCodec(conn))
	}
}
`````

````go
//client.go
package main

import (
	"fmt"
	"net"
	"net/rpc"
	"net/rpc/jsonrpc"
)

func main() {
	// 1. 建立连接
	conn, err := net.Dial("tcp", "localhost:1234")
	if err != nil {
		panic("连接失败")
	}
	//var reply *string = new(string)
	var reply string
	client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))
	err = client.Call("HelloService.Hello", "xin", &reply)
	if err != nil {
		panic("调用失败")
	}
	//fmt.Println(*reply)
	fmt.Println(reply)
}

//{"method": "HelloService.Hello", "params": ["xin"], "id":0}

````

`````python
# cli.py
import json
import socket

request = {
    "method": "HelloService.Hello",
    "params": ["xin"],
    "id": 0
}


client = socket.create_connection(("localhost", 1234))
client.sendall(json.dumps(request).encode())

# 获取服务器返回的数据
rsp = client.recv(4096)
rsp = json.loads(rsp.decode())
print(rsp)
`````

### rpc-http

`````go
//server.go
package main

import (
	"io"
	"net/http"
	"net/rpc"
	"net/rpc/jsonrpc"
)

type HelloService struct{}

func (s *HelloService) Hello(request string, reply *string) error {
	// 返回值是通过修改reply的值
	*reply = "Hello, " + request
	return nil
}

func main() {
	_ = rpc.RegisterName("HelloService", &HelloService{})
	http.HandleFunc("/jsonrpc", func(w http.ResponseWriter, r *http.Request) {
		var conn io.ReadWriteCloser = struct {
			io.Writer
			io.ReadCloser
		}{
			ReadCloser: r.Body,
			Writer:     w,
		}
		rpc.ServeRequest(jsonrpc.NewServerCodec(conn))
	})
	http.ListenAndServe(":1234", nil)
}
`````

## grpc

### python-protobuf

























