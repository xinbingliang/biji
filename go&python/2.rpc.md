#  rpc

远程过程调用

* Call ID的映射
* 序列化和反序列化
* 网络传输


## python默认RPC

### xml

`````python
from xmlrpc.server import SimpleXMLRPCServer

# 没有url的映射
# 没有编解码
class Calculate:
    def add(self, x, y):
        return x + y

    def multiply(self, x, y):
        return x * y

    def subtract(self, x, y):
        return abs(x - y)

    def divide(self, x, y):
        return x / y


obj = Calculate()
server = SimpleXMLRPCServer(("localhost", 8088))
# 将实例注册给rpc server
server.register_instance(obj)
print("Listening on port 8088")
server.serve_forever()
`````

````python
from xmlrpc import client

server = client.ServerProxy("http://localhost:8088")
print(server.add(2, 3))
````

1. 超时机制-重试

2. 限流 处于长时间可用的状态-高可用

3. 解耦

4. 负载均衡微服务-分布式应用的一种具体的体现

5. 序列化和反序列化数据压缩是否高效json这种数据格式已经非常的简单了 （这个序列化协议能将数据的压缩变得更小

   ）

6. 支持多语言

## go-rpc

````go
// server.go
package main

import (
	"net"
	"net/rpc"
)

type HelloService struct{}

func (s *HelloService) Hello(request string, reply *string) error {
	// 返回值是通过修改reply的值
	*reply = "Hello, " + request
	return nil
}

func main() {
	// 1. 实例化一个server
	listener, _ := net.Listen("tcp", ":1234") //启动一个tcp去监听
	// 2. 注册一个处理逻辑
	_ = rpc.RegisterName("HelloService", &HelloService{})
	// 3. 启动服务
	conn, _ := listener.Accept() // 新的连接进来使用套接字
	rpc.ServeConn(conn)
}
````

````go
//client.go
package main

import (
	"fmt"
	"net/rpc"
)

func main() {
	// 1. 建立连接
	client, err := rpc.Dial("tcp", "localhost:1234")
	if err != nil {
		panic("连接失败")
	}
	//var reply *string = new(string)
	var reply string
	err = client.Call("HelloService.Hello", "xin", &reply)
	if err != nil{
		panic("调用失败")
	}
	//fmt.Println(*reply)
	fmt.Println(reply)
}
````

### go-rpc-json

`````go
//server.go
package main

import (
	"net"
	"net/rpc"
	"net/rpc/jsonrpc"
)

type HelloService struct{}

func (s *HelloService) Hello(request string, reply *string) error {
	// 返回值是通过修改reply的值
	*reply = "Hello, " + request
	return nil
}

func main() {
	// 1. 实例化一个server
	listener, _ := net.Listen("tcp", ":1234") //启动一个tcp去监听
	// 2. 注册一个处理逻辑
	_ = rpc.RegisterName("HelloService", &HelloService{})
	// 3. 启动服务
	for {
		conn, _ := listener.Accept() // 新的连接进来使用套接字
		//rpc.ServeConn(conn)
		go rpc.ServeCodec(jsonrpc.NewServerCodec(conn))
	}
}
`````

````go
//client.go
package main

import (
	"fmt"
	"net"
	"net/rpc"
	"net/rpc/jsonrpc"
)

func main() {
	// 1. 建立连接
	conn, err := net.Dial("tcp", "localhost:1234")
	if err != nil {
		panic("连接失败")
	}
	//var reply *string = new(string)
	var reply string
	client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))
	err = client.Call("HelloService.Hello", "xin", &reply)
	if err != nil {
		panic("调用失败")
	}
	//fmt.Println(*reply)
	fmt.Println(reply)
}

//{"method": "HelloService.Hello", "params": ["xin"], "id":0}

````

`````python
# cli.py
import json
import socket

request = {
    "method": "HelloService.Hello",
    "params": ["xin"],
    "id": 0
}


client = socket.create_connection(("localhost", 1234))
client.sendall(json.dumps(request).encode())

# 获取服务器返回的数据
rsp = client.recv(4096)
rsp = json.loads(rsp.decode())
print(rsp)
`````

### rpc-http

`````go
//server.go
package main

import (
	"io"
	"net/http"
	"net/rpc"
	"net/rpc/jsonrpc"
)

type HelloService struct{}

func (s *HelloService) Hello(request string, reply *string) error {
	// 返回值是通过修改reply的值
	*reply = "Hello, " + request
	return nil
}

func main() {
	_ = rpc.RegisterName("HelloService", &HelloService{})
	http.HandleFunc("/jsonrpc", func(w http.ResponseWriter, r *http.Request) {
		var conn io.ReadWriteCloser = struct {
			io.Writer
			io.ReadCloser
		}{
			ReadCloser: r.Body,
			Writer:     w,
		}
		rpc.ServeRequest(jsonrpc.NewServerCodec(conn))
	})
	http.ListenAndServe(":1234", nil)
}
`````

## grpc

### python-protobuf

1. 安装

   ````
   python -m pip install grpcio #安装grpc
   python -m pip install grpcio-tools #安装grpc tools
   ````

2. 体验protobuf3

   ````protobuf
   syntax = "proto3";

   message HelloRequest {
     string name = 1; //name表示名称，编号为1
   }
   ````

3. 生成proto的python文件

   ````shell
   python -m grpc_tools.protoc --python_out=. --grpc_python_out=. -I. helloworld.proto
   ````

   * `python_out` 生成的`python protobuf`文件放在当前目录下
   * `grpc_python_out` 生成`grpc`的文件在当前目录下
   * `-I` 源文件再当前目录

4. 查看protobuf生成的代码

5. 尝试使用

   `````python
   from proto.hello_pb2 import HelloRequest

   request = HelloRequest()
   request.name = "xin"
   res_str = request.SerializeToString()
   print(res_str)

   # 反向生成对象
   request2 = HelloRequest()
   request2.ParseFromString(res_str)
   print(request2.name)
   `````

### python-grpc

````protobuf
syntax = "proto3";

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
//hello.proto
````

`````python
// server.py
from concurrent import futures

import grpc

from hello.proto import hello_pb2_grpc, hello_pb2


class Greeter(hello_pb2_grpc.GreeterServicer):
    def SayHello(self, request, context):
        return hello_pb2.HelloReply(message=f"{request.name}")


if __name__ == '__main__':
    # 1. 实例化server
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))  # 使用线程池
    # 2. 注册逻辑到server
    hello_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)
    # 3. 启动server
    server.add_insecure_port("0.0.0.0:5003")
    server.start()
    server.wait_for_termination()
    
`````

```python
import grpc

from hello.proto import hello_pb2, hello_pb2_grpc

if __name__ == '__main__':
    with grpc.insecure_channel("127.0.0.1:5003") as channel:
        stub = hello_pb2_grpc.GreeterStub(channel)
        rsp: hello_pb2.HelloReply = stub.SayHello(hello_pb2.HelloRequest(name="xin"))

        print(rsp.message)
```

### go-grpc






















