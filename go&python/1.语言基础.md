# go基础

## iota

`````go
package main

import "fmt"

func main() {
	const (
		A = iota
		B    // B=iota,复用上一行表达式
		C
	)
	fmt.Println(A, B, C)
	// iota只能在常量组中使用，各个常量组不相干扰
	// 没有表达式，复用上一行表达式
	// 从第一行开始iota从0逐行加1
	const (
		a = iota // 0
		b = 10 // 10
		c //10
		d, e = iota, iota //3 3  注意是逐行加一，即行数
		f = iota // 4
	)
	fmt.Println(a, b, c, d, e, f)
}
`````

## 类型转换

### 简单转换

### 使用strconv包

#### Itoa和Atoi

1. int转换为字符串：Itoa()

   `````go
   println("a" + strconv.Itoa(32))  // a32
   `````

2. string转换为int：Atoi()

   `````go
   i,_ := strconv.Atoi("3")
   println(3 + i)   // 6

   // Atoi()转换失败
   i,err := strconv.Atoi("a")
   if err != nil {
       println("converted failed")
   }
   //由于string可能无法转换为int，所以这个函数有两个返回值：第一个返回值是转换成int的值，第二个返回值判断是否转换成功。
   `````

#### Parse类函数

Parse类函数用于转换字符串为给定类型的值：ParseBool()、ParseFloat()、ParseInt()、ParseUint()

`````go
b, err := strconv.ParseBool("true")
f, err := strconv.ParseFloat("3.1415", 64)
i, err := strconv.ParseInt("-42", 10, 64)
u, err := strconv.ParseUint("42", 10, 64)
`````

ParseInt()和ParseUint()有3个参数：

````go
func ParseInt(s string, base int, bitSize int) (i int64, err error)
func ParseUint(s string, base int, bitSize int) (uint64, error)
````

说明：

1. 1. `bitSize`参数表示转换为什么位的int/uint，有效值为0、8、16、32、64。当bitSize=0的时候，表示转换为int或uint类型。例如bitSize=8表示转换后的值的类型为int8或uint8。
   2. `base`参数表示以什么进制的方式去解析给定的字符串，有效值为0、2-36。当base=0的时候，表示根据string的前缀来判断以什么进制去解析：`0x`开头的以16进制的方式去解析，`0`开头的以8进制方式去解析，其它的以10进制方式解析。

#### Format类函数

**将给定类型格式化为string类型**：FormatBool()、FormatFloat()、FormatInt()、FormatUint()。

````go
s,_ := strconv.FormatBool(true)
s,_ := strconv.FormatFloat(3.1415, 'E', -1, 64) // 64指位数
s,_ := strconv.FormatInt(-42, 16) //表示将-42转换为16进制数，转换的结果为-2a。
s,_ := strconv.FormatUint(42, 16)
````

第二个参数base指定将第一个参数转换为多少进制，有效值为`2<=base<=36`。当指定的进制位大于10的时候，超出10的数值以a-z字母表示。例如16进制时，10-15的数字分别使用a-f表示，17进制时，10-16的数值分别使用a-g表示。

FormatFloat()参数众多：

```
func FormatFloat(f float64, fmt byte, prec, bitSize int) string
```

bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。

fmt表示格式：'f'（-ddd.dddd）、'b'（-ddddp±ddd，指数为二进制）、'e'（-d.dddde±dd，十进制指数）、'E'（-d.ddddE±dd，十进制指数）、'g'（指数很大时用'e'格式，否则'f'格式）、'G'（指数很大时用'E'格式，否则'f'格式）。

prec控制精度（排除指数部分）：对'f'、'e'、'E'，它表示小数点后的数字个数；对'g'、'G'，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。

## python海象运算符

````python
course_list = ["go", "django", "PhP"]
if (course_size := len(course_list)) >= 3: # 3.8的语言特性
    print(len(course_list))
````

## python类型说明

````python
age: int = 18  # 声明类型
name: str = "xin"
````

`````python
from typing import List, Set, Dict, Tuple
courses: List[str] = ["django", "scrapy", "tornado"]
userinfo: Dict[str, float] = {"bobby": 72}
names: Tuple[int, ...] = (1, 2, 0, 3)
`````

## 函数参数类型

````python
def add(a: int, b: int=1) -> int:
    return a + b
````

没有做强制检测

**使用装饰器强制类型检测**

`````python
from functools import wraps
from inspect import getfullargspec
from typing import get_type_hints


def validate_input(obj, **kwargs):
    hints = get_type_hints(obj)
    for para_name, para_type in hints.items():
        if para_name == "return":
            continue
        if not isinstance(kwargs[para_name], para_type):
            raise TypeError("参数：{} 类型错误，应该是：{}".format(para_name, para_type))


def type_check(decorator):
    @wraps(decorator)
    def wrapped_decorator(*args, **kwargs):
        func_args = getfullargspec(decorator)[0]
        kwargs.update(dict(zip(func_args, args)))
        validate_input(decorator, **kwargs)
        return decorator(**kwargs)

    return wrapped_decorator


@type_check
def add(a: int, b: int) -> int:
    return a + b

print(add(1, 2.1))
`````

## 指针

````go
package main

import "fmt"

func main() {
	a := 10
	fmt.Printf("%p\n", &a)
	var ip *int
	ip = &a
	fmt.Println(*ip)
	*ip = 123
	fmt.Println(a)
	fmt.Printf("ip指向的内存空间地址是:%p，内存中的值是:%d\n", ip, *ip)

	a_list := [3]int{1, 2, 3}
	var ip_list *[3]int = &a_list
	fmt.Println(ip_list)

	//指针数组
	var ptrs [3]*int
}
````

* 大数据量下不适合值传递适合引用传递

 ## make、new、nil

`````go
package main

import "fmt"

func main() {
	//var p *int //申明一个变量p, 但变量没有初始值，没有内存，但p仍然占空间为nil，指针的使用会占用额外的空间
	//*p = 10    // 没有空间却赋值，报错

	//解决方式
	var p *int = new(int) //此时会申请一个内存空间初始化，值为默认的值
	*p = 10
	fmt.Println(p)

	// make更常用，new函数返回的是这个值的地址（指针），make函数返回的是指定类型的实例
	var info map[string]string = make(map[string]string)
	info["C"] = "bobby"
}
`````

### nil

````go
package main

import "fmt"

func main() {
	var info map[string]string
	if info == nil {
		fmt.Println("map的默认值是nil")
	}

	var slice []string
	if slice == nil {
		fmt.Println("slice的默认值是 nil")
	}

	var err error
	if err == nil {
		fmt.Println("error的默认值是 nil")
	}
	//nil是表示部分类型零值的标识符，代表不同的内存布局
}
````

## 函数

### 函数的返回值

### 函数的不定参数

`````go
package main

import "fmt"

func add(params ...int) (sum int) { // 不使用切片是为了避免变量被改变
	for _, v := range params {
		sum += v
	}
	return
}

func main() {
	fmt.Println(add(1, 2, 3, 3, 3))
	slice := []int{1, 21, 2, 1, 21, 2}
	fmt.Println(add(slice...))

	arr:=[...]int{1, 2, 3}
	fmt.Println("%T", arr)
}
`````

### 函数作为参数

1. 函数作为变量
2. ​













