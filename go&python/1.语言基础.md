# go基础

## iota

`````go
package main

import "fmt"

func main() {
	const (
		A = iota
		B    // B=iota,复用上一行表达式
		C
	)
	fmt.Println(A, B, C)
	// iota只能在常量组中使用，各个常量组不相干扰
	// 没有表达式，复用上一行表达式
	// 从第一行开始iota从0逐行加1
	const (
		a = iota // 0
		b = 10 // 10
		c //10
		d, e = iota, iota //3 3  注意是逐行加一，即行数
		f = iota // 4
	)
	fmt.Println(a, b, c, d, e, f)
}
`````

## 类型转换

### 简单转换

### 使用strconv包

#### Itoa和Atoi

1. int转换为字符串：Itoa()

   `````go
   println("a" + strconv.Itoa(32))  // a32
   `````

2. string转换为int：Atoi()

   `````go
   i,_ := strconv.Atoi("3")
   println(3 + i)   // 6

   // Atoi()转换失败
   i,err := strconv.Atoi("a")
   if err != nil {
       println("converted failed")
   }
   //由于string可能无法转换为int，所以这个函数有两个返回值：第一个返回值是转换成int的值，第二个返回值判断是否转换成功。
   `````

#### Parse类函数

Parse类函数用于转换字符串为给定类型的值：ParseBool()、ParseFloat()、ParseInt()、ParseUint()

`````go
b, err := strconv.ParseBool("true")
f, err := strconv.ParseFloat("3.1415", 64)
i, err := strconv.ParseInt("-42", 10, 64)
u, err := strconv.ParseUint("42", 10, 64)
`````

ParseInt()和ParseUint()有3个参数：

````go
func ParseInt(s string, base int, bitSize int) (i int64, err error)
func ParseUint(s string, base int, bitSize int) (uint64, error)
````

说明：

1. 1. `bitSize`参数表示转换为什么位的int/uint，有效值为0、8、16、32、64。当bitSize=0的时候，表示转换为int或uint类型。例如bitSize=8表示转换后的值的类型为int8或uint8。
   2. `base`参数表示以什么进制的方式去解析给定的字符串，有效值为0、2-36。当base=0的时候，表示根据string的前缀来判断以什么进制去解析：`0x`开头的以16进制的方式去解析，`0`开头的以8进制方式去解析，其它的以10进制方式解析。

#### Format类函数

**将给定类型格式化为string类型**：FormatBool()、FormatFloat()、FormatInt()、FormatUint()。

````go
s,_ := strconv.FormatBool(true)
s,_ := strconv.FormatFloat(3.1415, 'E', -1, 64) // 64指位数
s,_ := strconv.FormatInt(-42, 16) //表示将-42转换为16进制数，转换的结果为-2a。
s,_ := strconv.FormatUint(42, 16)
````

第二个参数base指定将第一个参数转换为多少进制，有效值为`2<=base<=36`。当指定的进制位大于10的时候，超出10的数值以a-z字母表示。例如16进制时，10-15的数字分别使用a-f表示，17进制时，10-16的数值分别使用a-g表示。

FormatFloat()参数众多：

```
func FormatFloat(f float64, fmt byte, prec, bitSize int) string
```

bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。

fmt表示格式：'f'（-ddd.dddd）、'b'（-ddddp±ddd，指数为二进制）、'e'（-d.dddde±dd，十进制指数）、'E'（-d.ddddE±dd，十进制指数）、'g'（指数很大时用'e'格式，否则'f'格式）、'G'（指数很大时用'E'格式，否则'f'格式）。

prec控制精度（排除指数部分）：对'f'、'e'、'E'，它表示小数点后的数字个数；对'g'、'G'，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。

## python海象运算符

````python
course_list = ["go", "django", "PhP"]
if (course_size := len(course_list)) >= 3: # 3.8的语言特性
    print(len(course_list))
````

## python类型说明

````python
age: int = 18  # 声明类型
name: str = "xin"
````

`````python
from typing import List, Set, Dict, Tuple
courses: List[str] = ["django", "scrapy", "tornado"]
userinfo: Dict[str, float] = {"bobby": 72}
names: Tuple[int, ...] = (1, 2, 0, 3)
`````

## 函数参数类型

````python
def add(a: int, b: int=1) -> int:
    return a + b
````

没有做强制检测

**使用装饰器强制类型检测**

`````python
from functools import wraps
from inspect import getfullargspec
from typing import get_type_hints


def validate_input(obj, **kwargs):
    hints = get_type_hints(obj)
    for para_name, para_type in hints.items():
        if para_name == "return":
            continue
        if not isinstance(kwargs[para_name], para_type):
            raise TypeError("参数：{} 类型错误，应该是：{}".format(para_name, para_type))


def type_check(decorator):
    @wraps(decorator)
    def wrapped_decorator(*args, **kwargs):
        func_args = getfullargspec(decorator)[0]
        kwargs.update(dict(zip(func_args, args)))
        validate_input(decorator, **kwargs)
        return decorator(**kwargs)

    return wrapped_decorator


@type_check
def add(a: int, b: int) -> int:
    return a + b

print(add(1, 2.1))
`````

## 指针

````go
package main

import "fmt"

func main() {
	a := 10
	fmt.Printf("%p\n", &a)
	var ip *int
	ip = &a
	fmt.Println(*ip)
	*ip = 123
	fmt.Println(a)
	fmt.Printf("ip指向的内存空间地址是:%p，内存中的值是:%d\n", ip, *ip)

	a_list := [3]int{1, 2, 3}
	var ip_list *[3]int = &a_list
	fmt.Println(ip_list)

	//指针数组
	var ptrs [3]*int
}
````

* 大数据量下不适合值传递适合引用传递

 ## make、new、nil

`````go
package main

import "fmt"

func main() {
	//var p *int //申明一个变量p, 但变量没有初始值，没有内存，但p仍然占空间为nil，指针的使用会占用额外的空间
	//*p = 10    // 没有空间却赋值，报错

	//解决方式
	var p *int = new(int) //此时会申请一个内存空间初始化，值为默认的值
	*p = 10
	fmt.Println(p)

	// make更常用，new函数返回的是这个值的地址（指针），make函数返回的是指定类型的实例
	var info map[string]string = make(map[string]string)
	info["C"] = "bobby"
}
`````

### nil

````go
package main

import "fmt"

func main() {
	var info map[string]string
	if info == nil {
		fmt.Println("map的默认值是nil")
	}

	var slice []string
	if slice == nil {
		fmt.Println("slice的默认值是 nil")
	}

	var err error
	if err == nil {
		fmt.Println("error的默认值是 nil")
	}
	//nil是表示部分类型零值的标识符，代表不同的内存布局
}
````

## 函数

### 函数的返回值

### 函数的不定参数

`````go
package main

import "fmt"

func add(params ...int) (sum int) { // 不使用切片是为了避免变量被改变
	for _, v := range params {
		sum += v
	}
	return
}

func main() {
	fmt.Println(add(1, 2, 3, 3, 3))
	slice := []int{1, 21, 2, 1, 21, 2}
	fmt.Println(add(slice...))

	arr:=[...]int{1, 2, 3}
	fmt.Println("%T", arr)
}
`````

### 将一个函数作为另外一个函数的参数

```go
// main.go
package main

import "fmt"

func filter(score []int, fun func(int) bool) []int {
	reSlice := make([]int, 0)
	for _, v := range score {
		if fun(v){
			reSlice = append(reSlice, v)
		}
	}
	return reSlice
}

func main() {
	score := []int{10, 50, 880, 90, 85}
	fmt.Println(filter(score, func(i int) bool {
		if i > 60 {
			return true
		}else {
			return false
		}
	}))
}
```

### python的finally

```python
def test():
    try:
        return "正常逻辑"
    except Exception as e:
        pass
    finally:  # 在正常返回之前执行
        print("执行finally")


if __name__ == '__main__':
    test()
```

### go中的defer

先进后出

```go
// main.go
package main

import "fmt"

func main() {
	fmt.Println("首先输出")
	defer fmt.Println("输出defer1")
	defer fmt.Println("输出defer2")
	defer fmt.Println("输出defer3")
	fmt.Println("代码末尾")
}
```

defer会拷贝，不会影响外部值

```go
// main.go
package main

import "fmt"

func main() {
	test := func() {
		fmt.Println("test1")
	}
	defer test()  // test1
	test = func() {
		fmt.Println("test2")
	}
}
```

### panic和recover

```go
// main.go
package main

import "fmt"

func div(a, b int) (int, error) {
	if b == 0{
 		panic("被除数不能为0")
	}else {
		return a/b, nil
	}
}

func main() {
	defer func() {
		err := recover() //从错误中恢复过来
		if err != nil{
			fmt.Println(err)
		}
		fmt.Println("hahahh")
	}()
	div(1, 0)
}
```

* 协程panic可能会导致主线程的挂掉
* 父协程无法捕获子协程的异常

`````go
package main

import (
	"fmt"
	"time"
)

func f1() {
	defer func() { //父线程拿不到子协程错误
		err := recover()
		if err != nil {
			fmt.Println("捕获到了")
		}
	}()

	go func() {
		//只能在子协程中自己捕获自己的异常
		panic("出错了")
	}()
	time.Sleep(10 * time.Second)
}

func main() {
	f1()
}
`````

## OOP

### type

1. 给一个类型定义别名，实际上为什么会有byte，别名用于强调类型，为了可读性

   ````go
   package main

   import "fmt"

   func main() {
   	type myByte = byte
   	var b myByte
   	fmt.Printf("%T", b)
   }
   ````

2. 基于已经有的类型定义一个新的类型

   ````go
   package main

   import "fmt"

   func main() {
   	type myByte byte
   	var b myByte
   	fmt.Printf("%T", b)
   }
   ````

3. 定义结构体

4. 定义接口

5. 定义函数别名

   ````go
   package main

   type handle func(str string)

   func main() {
   }
   ````

### 结构体赋值

`````go
package main

import "fmt"

type Person struct {
	Name string
	Age int32
	Sex string
}

func main() {
	person := Person{
		Name: "xinbingliang",
		Age: 0,
		Sex: "男",
	}
	fmt.Println(person)

	// 使用顺序形式
	p2 := Person{"xin", 12, "女"}
	fmt.Println(p2)

	// 使用指针指向的结构体
	p3 := &Person{"bing", 12, "男"}
	fmt.Printf("%T\n", p3)
	fmt.Println((*p3).Name, (*p3).Age, (*p3).Sex)
	fmt.Println(p3.Name, p3.Age, p3.Sex) //内部转换为上一行

	// 使用零值
	p4 := Person{}
	fmt.Println(p4)

	// 多种方式零值结构体
	var p5 Person = Person{}
	fmt.Println(p5)
	var p6 Person
	fmt.Println(p6)

	var p7 *Person = new(Person)
	fmt.Println(p5.Sex)
	fmt.Println(p6.Sex)
	fmt.Println(p7.Sex)

	var p8 *Person
	fmt.Println(p8.Sex) //没有创建空间的问题
}
`````

### 方法说明

* 直接操作结构体的值，或结构体数据量巨大使用指针传递参数


## 接口

### python鸭子类型

````python
from typing import Iterable


class Company():  # 类型不由继承决定
    def __init__(self, employee_list):
        self.employee = employee_list

    def __iter__(self):
        return iter(self.employee)


if __name__ == '__main__':
    company = Company(["tom", "bob", "jane"])
    if isinstance(company, Iterable):
        print("是可迭代类型")
    for em in company:
        print(em)
````





















