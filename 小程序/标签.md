# 标签和模版

## 标签

### view

view 视图容器相当于div

### scroll-view

可滚动区域图

* scroll-x 布尔值，允许横向滚动
* scroll-y 布尔值，允许纵向滚动
* upper-threshold 距顶部/左边多远时（单位px），触发 scrolltoupper 事件，默认50
* lower-threshold 距底部/右边多远时（单位px），触发 scrolltolower 事件
* scroll-top 设置竖向滚动条的位置
* scroll-left 设置横向滚动条位置
* scroll-into-view 值为某子元素的id，则滚动到该元素，元素顶部对齐滚动区域顶部
* bindscrolltoupper 滚动到顶部/左边，触发scrolltoupper事件
* bindscrolltolower 滚动到底部/右边，会触发scrolltolower事件
* bindscroll 滚动时触发，event.detail = {scrollLeft, scrollTop, scrollHeight, scrollWidth, deltaX, deltaY}


### swiper

轮播

- indicator-dots 布尔值，是否显示面板指示点
- autoplay 布尔值，是否自动切换
- current 当前所在页面的index
- interval 自动切换的时间间隔，5000
- duration 滑动动画时长,1000
- bindchange 切换时触发的事件

### swiper-item

防止在swiper中，宽和高自动设置为100%

```javascript
<swiper indicator-dots="true" autoplay="true" interval="4000" duration="1000" bindchange="change">
    <block wx:for="{{imgurls}}">
        <swiper-item>
            <image src="{{item}}" width="355" height="150"/>
        </swiper-item>
    </block>
</swiper>

Page({
    data: {
        imgurls:[
            "../../images/1.jpg",
            "../../images/2.jpg",
            "../../images/3.jpg",
            "../../images/4.jpg"
        ]
    },
    //在切换时被触发
    change: function(e){
        console.log(e);
    }
});
```

### icon

图标

- type 类型
  - success
  - success_no_circle
  - info
  - warn
  - waiting
  - cancel
  - download
  - search
  - clear
- size 大小默认23px
- color icon的颜色

```xml
<view>
    <block>
        <icon type="success" color="#abcdef"/>
    </block>
</view>
```

### text

文本，支持转义符，类似span，并且文本可以长按选中

### progress

- percent 百分比，使用0~100的数值
- show-info 布尔值，在进度条右侧显示百分比
- stroke-width 数值，进度条的宽度，单位px
- color 进度条的颜色
- active 是否有加载动画，布尔值

```xml
<progress percent="25" color="#abcdef" show-info="true" stroke-width="6" active="true"/>
```

## 表单控件

### button

按钮，boot-hover默认为{background-color: rgba(0, 0, 0, .1); opacity: 0.7;}

- size 按钮大小，有效值default，mini
- type 按钮的样式，primary,default,warn
- plain 按钮是否镂空，背景透明
- disabled 是否禁用
- loading 名称前是否带loading图标
- form-type 有效值，submit/reset
- hover-class 按钮按下的样式

```xml
<button sizeze="mini" type="warn" plain="true" disabled="false" loading="true" fom-type="submit">你好<button/>
```

### checkbox

checkbox-group` 多项选择器，内部由多个`checkbox`组成

- `bindchange` 当选中时触发

`checkbox`选项

- value 值
- disabled 是否禁用
- checked 当前是否选中

```javascript
Page({
    data: {
       items:[
           {
               name: "USA",
               value: "美国"
           },
           {
               name: "CN",
               value: "中国",
               checked: "true"
           },
           {
               name: "JP",
               value: "日本"
           }
       ]
    },
    change: function(){
        
    }
});

<checkbox-group bindchange="change">
    <label class="checkbox" wx:for="{{items}}">
        <checkbox value="{{item.name}}" checked="{{item.checked}}"/>{{item.value}}
    </label>
</checkbox-group>
```

### form

* report-submit 是否返回formId用来发送模版消息
* bindsubmit 提交时触发
* bindrest 重置时触发

### input

* value 输入框的初始内容
* type 输入框类型，text、number、idcard、digit
* password 是否是密码类型，布尔值
* placeholder 输入框为空提示
* placeholder-style 指定placeholder的样式
* disabled 布尔值，是否禁用
* maxlength 设置最大的输入长度，设置-1不限制最大长度
* auto-focus 布尔值，自动聚焦拉起键盘，页面中只有一个<input/>或<textarea>设置该值
* focus 布尔值，获取焦点（开发工具暂时不支持）
* bindinput 除了date/time类型外的输入框，当键盘输入时，触发input事件，event.detail = {value: value}，处理函数可以直接 return 一个字符串，将替换输入框的内容。
* bindfocus 当输入框获得焦点时触发，event.detail = {value:value}
* bindblur 输入框失去焦点时触发，event.detail = {value: value}


````html
<view class="section">
    <input placeholder="这是一个可以自动聚焦的的input" auto-focus/>
</view>
<view class="section">
    <input placeholder="这有点击按钮时才会获得焦点" focus="{{focus}}"/>
    <view class="btn-area">
        <button bindtap="bindButtonTap">使得输入框获得焦点</button>
    </view>
</view>
<view class="section">
    <input maxlength="10" placeholder="最大长度10"/>
</view>
<view class="section">
    <view class="section_title">你输入的是:{{inputValue}}</view>
    <input bindinput="bindKeyInput" placeholder="输入会发生同步"/>
</view>
<view class="section">
    <input bindinput="bindReplaceInput" placeholder="连续的两个1会变成2"/>
</view>
<view class="section">
    <input bindinput="bindHideKeybord" placeholder="输入123自动收取键盘"/>
</view>
<view class="section">
  <input type="digit" placeholder="带小数点的数字键盘"/>
</view>
<view class="section">
  <input type="idcard" placeholder="身份证输入键盘" />
</view>
<view class="section">
  <input placeholder-style="color:red" placeholder="占位符字体是红色的" />
</view>

Page({
    data: {
       focus: false,
       inputValue: '辛丙亮'
    },
    bindButtonTap: function(event){
        console.log('调用');
        this.setData({
            focus: true
        });
    }
    ,
    bindKeyInput: function(e){
        console.log('输入同步发生');
        this.setData({
            inputValue: e.detail.value
        })
    },
    bindHideKeyboard: function(){
        console.log('两个1变成2');
    },
    bindHideKeybord: function(e){
        if(e.detail.value == '123'){
            //收取键盘
            wx.hideKeyboard()
        }
    }
});
````


### label

for-id的对应绑定，支持的有`<button/>`、`<checkbox/>`、`<radio/>`、`<switch/>`

### picker

滚动选择器，支持普通选择，时间选择，日期选择，默认是普通选择

* 普通选择器 mode=selector
  * range 数组，为普通模式时有效
  * value 是数字，表示选择了第几个
  * bindchange 改变时触发，event.detail = {value: value}
* 时间选择器：mode=time
  * value 表示时间时间格式"hh:mm"
  * start 表示有效的时间范围的开始，字符串为"hh:mm"
  * end 表示有效时间范围的结束，字符串格式为"hh:mm"
  * bindchange value改变时触发change事件，event.detail = {value: value}
* 日期选择器
  * value 表示选择的日期，格式为:"YYYY-MM-DD"
  * start 表示有效日期范围的开始，字符串格式为:"YYYY-MM-DD"
  * end 表示有效日期范围的结束，字符串格式为"YYYY-MM-DD"
  * fields 有效值year,month,day，表示选择器的粒度
  * bindchange value改变时触发change事件，event.detail = {value: value}




```xml
<view class="section">
  <view class="section__title">地区选择器</view>
  <picker bindchange="bindPickerChange" value="{{index}}" range="{{array}}">
    <view class="picker">
      当前选择：{{array[index]}}
    </view>
  </picker>
</view>
<view class="section">
  <view class="section__title">时间选择器</view>
  <picker mode="time" value="{{time}}" start="09:01" end="21:01" bindchange="bindTimeChange">
    <view class="picker">
      当前选择: {{time}}
    </view>
  </picker>
</view>

<view class="section">
  <view class="section__title">日期选择器</view>
  <picker mode="date" value="{{date}}" start="2015-09-01" end="2017-09-01" bindchange="bindDateChange">
    <view class="picker">
      当前选择: {{date}}
    </view>
  </picker>
</view>


Page({
  data: {
    array: ['美国', '中国', '巴西', '日本'],
    index: 0,
    date: '2016-09-01',
    time: '12:01'
  },
  bindPickerChange: function(e) {
    console.log('picker发送选择改变，携带值为', e.detail.value)
    this.setData({
      index: e.detail.value
    })
  },
  bindDateChange: function(e) {
    this.setData({
      date: e.detail.value
    })
  },
  bindTimeChange: function(e) {
    this.setData({
      time: e.detail.value
    })
  }
})
```


### radio

* radio-group
  * bindchange 选中项发生变化时触发change事件，event.detail = {value: 选中项radio的value}
* radio
  * value  当该选中时，的change事件会携带的value
  * checked 当前是否选中
  * disabled 是否禁用

```xml
<radio-group class="radio-group" bindchange="radioChange">
  <label class="radio" wx:for="{{items}}">
    <radio value="{{item.name}}" checked="{{item.checked}}"/>{{item.value}}
  </label>
</radio-group>

Page({
  data: {
    items: [
      {name: 'USA', value: '美国'},
      {name: 'CHN', value: '中国', checked: 'true'},
      {name: 'BRA', value: '巴西'},
      {name: 'JPN', value: '日本'},
      {name: 'ENG', value: '英国'},
      {name: 'TUR', value: '法国'}
    ]
  },
  radioChange: function(e){
    console.log(e.detail.value)
  }
})
```

### slider

滑动选择器

* min 最小值，默认0
* max 最大值，最大值
* step 步长，取值必须大于0
* disabled 是否禁用
* value 当前取值，默认0
* show-value 是否显示当前value，默认false
* bindchange 完成一次拖动后触发的事件，event.detail = {value: value}

```xml
<slider bindchange="slider1change" left-icon="cancel" right-icon="success_no_circle"/>
```

### swith

开关选择器

* checked 是否选中
* type 样式switch，checkbox
* bindchange checked改变时触发change事件，event.detail={ value:checked}

````xml
<view class="body-view">
    <switch checked bindchange="switch1Change"/>
    <switch bindchange="switch2Change"/>
</view>
````

### textarea

* value 输入框内容
* placeholder 输入框占位符
* placeholder-style 指定placeholder的样式
* placeholder-class 指定placeholder的样式类
* disabled 是否禁用
* maxlength 最大输入长度，默认140
* auto-focus 自动聚焦，拉起键盘
* focus 获取焦点
* auto-height 是否自动增高，设置auto-height时，style.height不生效
* bindfocus 输入框聚焦时触发，event.detail = {value: value}
* bindblur 输入框失去焦点时触发，event.detail = {value: value}
* bindlinechange 输入框行数变化时调用，event.detail = {height: 0, heightRpx: 0, lineCount: 0}


```html
<view>
  <textarea bindblur="bindTextAreaBlur" auto-height placeholder="高度自动扩展"/>
</view>
<view>
  <textarea placeholder="提示颜色是红色的" placeholder-style="color:red"/>
</view>
<view>
  <textarea placeholder="自动聚焦的" auto-focus/>
</view>
<view>
  <textarea placeholder="点击按钮获得焦点" focus="{{focus}}"/>
  <view>
    <button bindtap="bindButtonTap">获得焦点</button>
  </view>
</view>

Page({
  data: {
    height: 20,
    focus: false
  },
  bindButtonTap: function(){
    this.setData({
      focus: true
    })
  },
  bindTextAreaBlur: function(e){
    console.log(e.detail.value);
  }
})
```


### text 

* 相当于span，可以长按复制

## 导航

* url 应用内的跳转链接
* redirect 是否关闭当前页面
* hover-class 点击时样式类

## 媒体组件

### audio

* id  video组件唯一标识符
* src 播放的音源地址
* loop 是否循环播放
* controls 是否显示默认控件
* poster 默认控件上的音频封面的图片资源地址，如果 controls 属性值为 false 则设置 poster 无效
* name 默认控件上的音频名字，如果 controls 属性值为 false 则设置 name 无效
* author 默认控件上的作者名字，如果 controls 属性值为 false 则设置 author 无效
* binderror 当发生错误时触发 error 事件，detail = {errMsg: MediaError.code}
* bindplay 当开始/继续播放时触发play事件
* bindpause 当暂停播放时触发 pause 事件
* bindtimeupdate 当播放进度改变时触发 timeupdate 事件，detail = {currentTime, duration}
* bindended 当播放到末尾时触发 ended 事件


错误码

* MEDIA_ERR_ABORTED 获取资源被用户禁止
* MEDIA_ERR_NETWORD 网络错误
* MEDIA_ERR_DECODE 解码错误
* MEDIA_ERR_SRC_NOT_SUPPOERTED 不合适资源

### image

* src 图片资源地址
* mode 图片裁剪缩放模式
* binderror 当错误发生时，发布到 AppService 的事件名，事件对象event.detail = {errMsg: 'something wrong'}
* bindload 当图片载入完毕时，发布到 AppService 的事件名，事件对象event.detail = {height:'图片高度px', width:'图片宽度px'}


* 3种缩放
  * scaleToFill 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素
  * aspectFit 保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。
  * aspectFill 保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。
* 9种裁剪
  * top 不缩放图片，只显示图片的顶部区域
  * bottom 不缩放图片，只显示图片的底部区域
  * center 不缩放图片，只显示图片的中间区域
  * left 不缩放图片，只显示图片的左边区域
  * right 不缩放图片，只显示图片的右边区域
  * top left 不缩放图片，只显示图片的左上边区域
  * top right 不缩放图片，只显示图片的右上边区域
  * bottom left 不缩放图片，只显示图片的左下边区域
  * bottom right 不缩放图片，只显示图片的右下边区域

```html
<image style="width: 200px; height: 200px; background-color: #eeeeee;" mode="{{item.mode}}" src="{{src}}"></image>
```

### video

video标签认宽度300px、高度225px，设置宽高需要通过wxss设置width和height。

* src 要播放视频的资源地址
* controls 是否显示默认播放控件(播放/暂停按钮、播放进度、时间)
* danmu-list 弹幕列表
* danmu-btn 是否显示弹幕按钮，只在初始化时有效，不能动态修改
* enable-danmu 是否展示弹幕，只在初始化时有效，不能动态变更
* autoplay 是否自动播放
* bindplay 当开始/继续播放时触发play事件
* bindpause 当暂停播放时触发pause事件
* bindended 当播放到末尾时触发ended事件
* binderror 当发生错误时触发error事件，event.detail = {errMsg: 'something wrong'}

## 地图

* longitude 中心经度
* latitude 中心纬度
* scale 缩放级别
* markers 标记点
* covers 覆盖物

### 标记点

标记点用于在地图上显示标记的位置，不能自定义图标和样式

* latitude 纬度
* longitude 经度
* name 标注点名
* desc 标注点详细描述

### 覆盖物

* latitude 纬度
* longitude 经度
* iconPath 显示的图标
* rotate 旋转角度

## 画布

* canvas-id canvas组件的唯一标识符
* disable-scoll 当在canvas中移动时，禁止屏幕滚动以及下拉刷新
* bindtouchstart 手指触摸动作开始
* bindtouchmove 手指触摸后移动
* bindtochend 手指触摸结束
* bindtotouchcancel 手指触摸动作被打断，如来电提醒，弹窗
* binderror 当发生错误时触发 error 事件，detail = {errMsg: 'something wrong'}

### 字体

* rpx



## 模版

```xml
<!-- 定义模版 name为模版名称 -->
<template name="header">
    <view>这是头部</view>
</template>

<!-- 使用模版 is指定模版名称 -->
<template is="header"></template>
```

### 模版绑定数据需要data指定

```xml
<!-- 定义模版 name为模版名称 -->
<template name="header">
    <view>{{title}}</view>
</template>

<!-- 使用模版 is指定模版名称 data传递的值 -->
<template is="header" data="{{title}}"></template>

<!-- 传递多个值 -->
<template is="header" data="{{title,name}}"></template>
```

### 外部模版引入

* import

  ```xml
  //header文件
  <template name="header">
      <view>底部</view>
  </template>

  <!-- 引入模版 -->
  <import src="../../temp/header.wxml"/>

  <!-- 使用模版 -->
  <template is="header"></template>
  ```

  只能引入定义好的模版，C import B，B import A，在C中可以使用B定义的template，在B中可以使用A定义的template，但是C不能使用A定义的template

* include

```xml
<!-- 头部文件 -->
<view>dsfbdsf</view>

<!-- 引入模版 -->
<include src="../../temp/header.wxml"/>
```

不解析template，仅引入外部，忽略template


