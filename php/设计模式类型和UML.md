# 设计模式分类和用途

## 分类和用途

* 创建型模式

| 模式名称       | 描述                                       |
| ---------- | ---------------------------------------- |
| 抽象工厂模式     | 为一个产品族提供统一的创建接口，当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类 |
| 工厂方法模式     | 定义一个接口用于创建对象，但是让子类决定初始化哪个类，工厂方法把一个类的初始化下放到子类 |
| 生成器模式（建造者） | 将一个复杂的的对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示   |
| 惰性初始化      | 推迟对象的创建、数据的计算等需要耗费较多资源的操作，只在第一次访问的时候才访问  |
| 对象池模式      | 通过回收利用对象避免获取和释放资源所需要的昂贵成本                |
| 原型模式       | 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象           |
| 单例模式       | 确保一个类只有一个实例，并提供对该实例的全局访问。                |

* 结构性模式

| 模式名   | 描述                                       |
| ----- | ---------------------------------------- |
| 适配器模式 | 将某个类的接口转化为客户端期望的另一个接口。适配器模式可以消除接口不匹配造成的类的兼容性问题 |
| 桥接模式  | 将一个抽象与实现解耦，使两者可以独立变化                     |
| 组合模式  | 把多个对象对象组成树状结构来表示局部和整体，这样用户可以一样对待单个对象和对象的组合 |
| 装饰器模式 | 向某个对象动态的添加更多的功能，装饰器模式是除类继承外另外的一种扩展功能的方法  |
| 外观模式  | 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这个子子系统更加容易使用 |
| 享元模式  | 通过共享以便有效的支持大量的小颗粒对象                      |
| 代理    | 为其他对象提供一个代理控制对这个对象的访问                    |

* 行为型模式

| 模式名  | 描述                                       |
| ---- | ---------------------------------------- |
| 黑板   | 广义的观察者在系统范围内交流信息，允许多位读者和写者               |
| 责任链  | 为解除请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理他 |
| 命令   | 将一个请求封装一个对象，从而使你可用不同的请求对客户端进行参数化，对请求排队或记录请求日志，以及支持可取消的操作 |
| 解释器  | 给定的语言，定义他的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子 |
| 迭代器  | 提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露给对象的内部表示    |
| 中介者  | 包装一系列对象相互作用的方式，使得这些对象不必相互明显作用，从而使他们可以松散耦合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立变化 |
| 备忘录  | 备忘录对象是一个用来存储另外一个对象内部状态的快照对象，备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住， |
| 空对象  | 通过提供默认对象来避免空引用                           |
| 观察者  | 在对象间定义一个一对多的联系性，由此当一个对象改变状态，所有其他相关的对象会被通知并且自动刷新 |
| 规格   | 以布尔形式表示的可重绑定的商业逻辑                        |
| 状态   | 让一个对象在其内部状态改变的时候，其行为也随之改变，状态模式需要每一个系统可能获取的状态创立一个状态类的子类，当系统状态变化时，系统状态变化时，系统便改变所选的子类 |
| 策略   | 定义一个算法的系列，将其各个封装，并且使他们有交互性。策略模式使得算法在用户使用的时候能独立改变 |
| 模版方法 | 模版方法模式准备一个抽象类，将部分逻辑以具体方法及具体构造子类的形态实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现，先构建一个顶级逻辑框架，而将逻辑的细节留给具体的子类实现。 |
| 访问者  | 封装一些施加于某种元素之上的操作，一旦完成这些操作需要修改，接受这个操作数据结构可以保持不变，访问者模式适用于数据结构相对未定的系统。把数据结构作用于结构上的操作之间的耦合解脱开，使得操作合集可以相对自由的演化 |

## UML图

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid108299labid2293timestamp1478843259466.png/wm)

- 车的类图结构为<>，表示车是一个抽象类；
- 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；
- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；
- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；
- 学生与班级之间是聚合关系，使用带空心箭头的实线表示；
- 学生与身份证之间为关联关系，使用一根实线表示；
- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；


## UML类图和类的关系

在线UML类图关系制作工具:[processon](http://www.processon.com/)

类关系种类:

* 泛化(Generalization)
* 实现(Realization)
* 依赖(Dependency)
* 关联(Association)
  * 关联关系
  * 聚合关系
* 合成关系

### 类图

显示系统中的类接口、接口以及他们之间的静态结构和关系的一种静态模型，一个类图的3个基本组件：类名、属性、方法

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid108299labid2293timestamp1479198500927.png/wm)

### 泛化(generalization)

表示is-a的关系，是对象之间耦合程度最大的一种关系，子类继承父类的所有细节，直接使用语言中的继承表达，使用带三角箭头的实线表示，箭头从子类指向父类。

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid108299labid2293timestamp1479198831858.png/wm)

* 继承可以使用空心箭头

### 实现(Realization)

就是接口和实现的关系，在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid108299labid2293timestamp1479199007927.png/wm)

* 接口实现也可以使用空心箭头

### 关联关系(Association)

一般用来定义类之间的静态的，天然的结构，所以关联关系是一种强关联关系，由常识所决定

学生与学校之间的关系

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid108299labid2293timestamp1479199479813.png/wm)

### 依赖关系(Dependency)

A依赖于B，表示一个对象在运行期间会用到另一个对象的关系，这种关系是弱关联方式，一般指局部变量，函数参数，返回值建立对于其他对象的调用，一个类调用被依赖类中的某些方法而得以完成这个类的一些职责，使用带箭头的虚线表示，箭头从使用类指向被依赖的类

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid108299labid2293timestamp1479199678874.png/wm)

### 聚合(Aggregation)

表示has-a的关系，是一种不稳定的包含关系，较强于一般关联，有整体和局部之间的关系，没有整体，局部也可以单独存在，如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司，使用空心菱形表示，菱形从局部指向整体

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid108299labid2293timestamp1479199877080.png/wm)

### 组合(Composition)

表示conttains-a的关系，是一种强烈的包含关系，组合类负责被组合类的生命周期，组合类负责被组合类的生命周期，是一种更强的聚合关系，部分不能脱离整体而存在，例如公司不存在部门就不会再存在了，使用实心的菱形表示，菱形从局部指向整体

![此处输入图片的描述](https://dn-anything-about-doc.qbox.me/document-uid108299labid2293timestamp1479199980657.png/wm)

* UML时序图