# process

## exit codes

Node 执行程序正常情况下会返回 0，这也意味着，包括所有“异步”在内的操作都已结束。

- 1 未捕获的致命异常
- 2 未使用
- 3 解析错误
- 4 评估失败
- 5 致命错误
- 6 未正确的异常处理
- 7 异常处理函数运行时失败
- 8 未使用
- 9 无效的参数
- 10 运行时失败
- 12 无效的调试参数
- `>`128 信号退出

## 方法

### process.abort()

Node 触发一个abort事件，这会导致Node退出并且创建一个核心文件；

### process.chdir(directory)

改变进程当前的工作目录，操作失败将抛出异常

```javascript
'use strict';

console.log('当前目录：' + process.cwd());
try{
	process.chdir('/tmp');
	console.log('新目录：' + process.cwd());
}catch(err){
	console.log('chdir：' + err)
}
```

### process.cwd()

返回当前进程的工作目录

### process.exit([code])

终止当前进程并返回给定的 `code`

### process.getgid()

获取进程的群组标识

### process.setgid()

设置进程的群组标识

### process.getuid()

获取执行进程的用户ID

### process.setuid(id)

设置执行进程的用户ID

### process.getgroups()

返回一个保存补充组ID(

### process.setgroups(groups)

设置补充分组的ID标识

### process.initgroups(user, extra_group)

读取 /etc/group 并且初始化group分组访问列表，使用改成员所在的所有分组， 这是一个特殊的操作, 意味着你必须拥有root或者CAP_SETGID权限才可以。

### process.kill(pid, [signal])

向进程发送一个信号。 `pid` 是进程的 id 而 `signal` 则是描述信号的字符串名称。信号的名称都形似 'SIGINT' 或者 'SIGUSR1'。如果没有指定参数则会默认发送 'SIGTERM' 信号，更多信息请查看 kill(2) 。

### process.memoryUsage()

返回一个对象，它描述了Node进程的内存使用情况单位是bytes

```javascript
'use strict';

console.log(process.memoryUsage())
```

### process.nextTick(callback)

在事件循环的下一次循环中调用 callback 回调函数

```javascript
console.log('开始');
process.nextTick(function() {
  console.log('nextTick 回调');
});
console.log('已设定');
```

### process.umask([mask\])

设置或者读取进程的文件模式的创建掩码

### process.uptime()

返回 Node 程序已运行的秒数。

### process.hrtime()

返回当前的高分辨时间，形式为 `[秒，纳秒]` 的元组数组。

## 属性

### process.stdout

一个指向标准输出流的可写的流，是阻塞式写入的

````javascript
'use strict';
process.stdout.write('some message!');
````

检测Node是否在运行一个TTY上下文，使用 process.stderr、process.stdout 或 process.stdin 的 isTTY 属性

### process.stderr

一个指向标准错误流的可写的流

````javascript
'use strict';
process.stderr.write('some message!');
````

### process.stdin

一个指向标准输入流的可读流，标准输入流默认是暂停(pause)的，所以必须调用process.stdin.resume来恢复接收

### process.argv

获得命令行参数数组

````javascript
'use strict';

console.log(process.argv)
````

### process.execPath

开启当前进程的绝对路径

### process.execArgv

保存 node特殊(node-specific) 的命令行选项（参数）

```javascript
'use strict';
console.log(process.execArgv)

node --harmony client.js 1 2 3 4 5 6 7 8 //调用
```

### process.env

环境变量

### process.exitCode

当进程既正常退出，或者通过未指定 code 的 `process.exit()` 退出时，这个属性中所存储的数字将会成为进程退出的错误码 (exit code)。

如果指名了 `process.exit(code)` 中退出的错误码 (code)，则会覆盖掉 `process.exitCode` 的设置。

### process.version

一个暴露编译时存储版本信息的内置变量 `NODE_VERSION` 的属性。

### process.versions

一个暴露存储 node 以及其依赖包 版本信息的属性

### process.config

一个包含用来编译当前 node.exe 的配置选项的对象

### process.pid

当前进程的 PID

### process.title

获取/设置 (Getter/setter) 'ps' 中显示的进程名。

### process.arch

返回当前 CPU 处理器的架构：'arm'、'ia32' 或者 'x64'.

### process.platform

返回当前程序运行的平台：`'darwin'`, `'freebsd'`, `'linux'`, `'sunos'` 或者 `'win32'`



## 事件

### exit

当该进程退出时触发

````javascript
//server.js
'use strict';

setInterval(function(){
  console.log('正在执行中');
  setTimeout(function(){
    process.exit(0);
  }, 3000)
}, 1000);

//client.js
process.on('exit', function(){
  console.log('退出前执行');
});
````

### uncaughtException(未捕获的错误)

粗糙的异常处理机制，不具备重新拉起程序的价值，建议少用

````javascript
'use strict';

process.on('uncaughtException', function(err){
  console.log('发生系统级别异常：' + err);
});


setTimeout(function(){
  console.log('整个程序将发生致命错误');

  nonexistentFunc();
}, 3000);
````

### signal Events

进程接受接受到信号

```javascript
'use strict';

process.on('SIGINT', function(){
  console.log('进程收到信号')
})

setTimeout(function(){
  console.log('程序没有收到信号已经退出。。。。。。')
}, 10000)
```

## 使用案例

### 使用exit事件监听避免出错宕掉整个服务

```javascript
'use strict';
const http = require('http');

let server = http.createServer(function(req, res){
	res.writeHead(200, {});
	res.end('响应');
	
	badFunc();	//执行一个不存在的方法
	
	console.log('sent response');
});

process.on('uncaughtException', function(e){	//官方不建议使用该方法重新拉起服务
	console.log(e);
})

server.listen(8080)
```

### 事件循环















