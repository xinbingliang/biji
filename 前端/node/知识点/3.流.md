# Stream

* Readable 可读流(`fs.createReadStream()`)
* Writeable 可写流(`fs.createWriteStream()`)
* Duplex 可读可写双工流(`net.Socket`)
* Transform  在读取或写入数据时修改或转换数据的双工流(`zlib.createDefault()`)

## 可读流

### 事件

#### readable

当一个数据块可以从流中被读出时，它会触发一个 `'readable'` 事件，当内部缓冲区被排空后，一旦更多数据时，一个 `readable` 事件会被再次触发

```javascript
let readable = fs.createReadStream('./data.txt');

readable.on('readable', function(){
    console.log('数据已经可读');
})
```

#### data

绑定一个 `data` 事件监听器到一个未被明确暂停的流会将流切换到流动模式，数据会被尽可能地传递。

#### end

该事件会在没有更多数据能够提供时被触发。

#### close

当底层数据源（比如，源头的文件描述符）被关闭时触发。并不是所有流都会触发这个事件。

#### error

当数据接收时发生错误时触发。

```javascript
'use strict';

const fs = require('fs');

let readable = fs.createReadStream('./data.txt');

readable.on('readable', function(){
    console.log('数据已经可读');
})

let data = '';

readable.on('data', function(chunck){
    data += chunck.toString('utf8');
});

readable.on('end', function(){
    console.log(data);
});

readable.on('close', function(){
    console.log('关闭数据源');
});

readable.on('error', function(err){
    console.log(err);
});
```

### 方法

#### readable.read([size])

- `size` {Number} 可选参数，指定要读取多少数据。
- 返回 {String | Buffer | null}

```javascript
const fs = require('fs');

let readable = fs.createReadStream('./data.txt');

readable.on('readable', ()=>{
  let chunk = readable.read(1024);
  console.log(chunk.toString('utf8'));
})
```

#### readable.setEncoding(encoding)

- `encoding` {String} 要使用的编码。
- 返回: `this`

调用此函数会使得流返回指定编码的字符串而不是 Buffer 对象。

```javascript
'use strict';

const fs = require('fs');

let readable = fs.createReadStream('./data.txt');

readable.setEncoding('utf8');

readable.on('readable', ()=>{
  let chunk = readable.read(1024);
  console.log(chunk);
})
```

#### readable.resume()

- 返回: `this`

该方法让可读流继续触发 `data` 事件。

该方法会将流切换到流动模式。如果您*不想*从流中消费数据，但您*想*得到它的 `end` 事件，您可以调用 [`readable.resume()`](http://www.nodeclass.com/api/node.html#stream_readable_resume) 来启动数据流。

#### readable.pause()

- 返回: `this`

该方法会使一个处于流动模式的流停止触发 `data` 事件，切换到非流动模式，并让后续可用数据留在内部缓冲区中。

```javascript
'use strict';

const fs = require('fs');

let readStream = fs.createReadStream('./data.txt');
let writeStream = fs.createWriteStream('./~data.txt');

readStream.on('data', (data)=>{
  if(writeStream.write(data) == false){ //数据没有被写完
    readStream.pause();   //暂停读取流
  }
})

writeStream.on('drain', ()=>{ //可以继续向写入流中做操作
  readStream.resume();  //恢复流的读取
})

readStream.on('end', function(){  //读取完毕
  writeStream.end();
})
```

#### readable.pipe([destination], [options])

- `destination` {[Writable](http://www.nodeclass.com/api/node.html#stream_class_stream_writable) Stream} 写入数据的目标
- `options` {Object} 导流选项`end` {Boolean} 在读取者结束时结束写入者。缺省为 `true`

该方法从可读流中拉取所有数据，并写入到所提供的目标。该方法能自动控制流量以避免目标被快速读取的可读流所淹没。

可以导流到多个目标。

```javascript
var fs = require("fs");
var readerStream = fs.createReadStream('data.txt');
var writerStream = fs.createWriteStream('output.txt');

readerStream.pipe(writerStream);
```

**链式操作**

```javascript
const fs = require('fs');
const zlib = require('zlib');

fs. createReadStream('./data.txt').pipe(zlib.createGzip()).pipe(fs.createWriteStream('./data.gz'));
```

```javascript
const fs = require('fs');
const zlib = require('zlib');

fs. createReadStream('./data.gz').pipe(zlib.createGunzip()).pipe(fs.createWriteStream('back.txt'));
```

**在末尾添加信息**

```javascript
var fs = require("fs");
var readerStream = fs.createReadStream('data.txt');
var writerStream = fs.createWriteStream('output.txt');

readerStream.pipe(writerStream, { end: false });

readerStream.on('end', ()=>{
  writerStream.write('ending....\r\n');
})
```

#### readable.unpip([destination])

- `destination` {[Writable](http://www.nodeclass.com/api/node.html#stream_class_stream_writable) Stream} 可选，指定解除导流的流

该方法会移除之前调用 `pipe()` 所设定的钩子。如果不指定目标，所有导流都会被移除。如果指定了目标，但并没有与之建立导流，则什么事都不会发生。

```javascript
'use strict';

const fs = require("fs");

let readSteam = fs.createReadStream('./data.txt');
let writeStream = fs.createWriteStream('./~data.txt');

readSteam.pipe(writeStream);
setTimeout(()=>{
  readSteam.unpipe(writeStream);

  writeStream.end();
}, 3)
```

#### readable.unshift(chunck)



















