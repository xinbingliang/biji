# Stream

* Readable 可读流(`fs.createReadStream()`)
* Writeable 可写流(`fs.createWriteStream()`)
* Duplex 可读可写双工流(`net.Socket`)
* Transform  在读取或写入数据时修改或转换数据的双工流(`zlib.createDefault()`)

## 可读流

### 事件

#### readable

当一个数据块可以从流中被读出时，它会触发一个 `'readable'` 事件，当内部缓冲区被排空后，一旦更多数据时，一个 `readable` 事件会被再次触发

```javascript
let readable = fs.createReadStream('./data.txt');

readable.on('readable', function(){
    console.log('数据已经可读');
})
```

#### data

绑定一个 `data` 事件监听器到一个未被明确暂停的流会将流切换到流动模式，数据会被尽可能地传递。

#### end

该事件会在没有更多数据能够提供时被触发。

#### close

当底层数据源（比如，源头的文件描述符）被关闭时触发。并不是所有流都会触发这个事件。

#### error

当数据接收时发生错误时触发。

```javascript
'use strict';

const fs = require('fs');

let readable = fs.createReadStream('./data.txt');

readable.on('readable', function(){
    console.log('数据已经可读');
})

let data = '';

readable.on('data', function(chunck){
    data += chunck.toString('utf8');
});

readable.on('end', function(){
    console.log(data);
});

readable.on('close', function(){
    console.log('关闭数据源');
});

readable.on('error', function(err){
    console.log(err);
});
```

### 方法

#### readable.read([size])

- `size` {Number} 可选参数，指定要读取多少数据。
- 返回 {String | Buffer | null}

#### readable.setEncoding(encoding)



#### readable.resume()



#### readable.pause()



#### readable.pipe([destination], [options])



#### readable.unpip([destination])



#### readable.unshift(chunck)



#### readable.wrap(stream)















