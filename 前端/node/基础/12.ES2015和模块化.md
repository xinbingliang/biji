# 模块化和ES2015

## 自定义模块和单元测试

````javascript
//app.js
'use strict'
var mod = require('./mode/mod.js');

mod.show()

````

```javascript
function show(){
	console.log(__dirname);
	console.log(__filename);
}

module.exports = {show}

//该方法用来做单元测试

if(!module.parent){
	show();
}
```

### require加载规则

- `require('./module')`此时执行JS文件
- `require('./module.js')` 此时执行JS文件
- `require('./module.json')` 解析json文件
- `require('./module.node')` 执行预编译后的C++模块
- `require('./module')` 加载module文件夹下的`index.js`
- 目录下有`package.json`中有main设置
- 不以`.`开头就找系统模块(或模块包)
- 以`/`开头就以系统根目录加载(少用，读文件才用绝对路径)
- `./`和`../`都是被支持的

## require缓存问题

```javascript
'use strict'

setInterval(()=>{
	//清除全部缓存
	Object.keys(require.cache).forEach(function(key){
		delete require.cache[key];
	});

	var date = require('./module/date');

	console.log(date.date.getTime());
}, 1000);

//date.js
module.exports = {date: new Date()};
```

当每次模块有更新，就以函数方式导出

```javascript
module.exports = () => {
	return new Date();
};
```

## 常量

```javascript
const A = 10;
console.log(A)

const B = {a:10}
console.log(B)
//常量对象，对象内容依然可以被修改
B.a = 123
```

一般将载入的模块都使用常量

## 局部作用域变量

```javascript
function func(){
	for (let i = 0; i < 10; i++){
		console.log(i);
	}
}

func()
```

希望在循环结束后i立刻会被销毁，javascript中能使用`let`和`const`就不要使用`var`

`babel.js`将`ES2015`转化为`ES5`











