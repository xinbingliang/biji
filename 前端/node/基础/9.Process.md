#process

process模块允许你获得或者修改当前node进程的设置，并和它进行交互

## 进程方法

#### 程序退出时被执行，在执行完成后退出触发，而不是`CTRL+C`后触发

```javascript
process.on('exit', function () {	//监听当前进程是否退出
　　setTimeout(function () {			//该语句不会被执行，当进程退出后不再存在执行的环境
　　　　console.log('This will not run');
　　}, 100);
　　console.log('Bye.');	
});
```

#### 避免出错宕掉整个程序

```javascript
var http = require('http');
var server = http.createServer(function(req,res) {
　　res.writeHead(200, {});
　　res.end('response');
　　badLoggingCall('sent response');			//执行一个并不存在的方法
　　console.log('sent response');
});
process.on('uncaughtException', function(e) {	//监听异常的发生，会捕获到错误的发生但不会关闭程序
　　console.log(e);
});
server.listen(8080);
```

## 事件循环

```javascript
var http = require('http');
var s = http.createServer(function(req, res) {
　　res.writeHead(200, {});
　　res.end('foo');
　　console.log('http response');
　　process.nextTick(function(){console.log('tick')});	//在下次tick的时候执行
});
s.listen(8000);
```

```javascript
process.on('uncaughtException', function(e) {
　　console.log(e);
});
process.nextTick(function() {
　　console.log('tick');
});
process.nextTick(function() {	
　　iAmAMistake();
　　console.log('tock');	//因为出错而不会被执行
});
process.nextTick(function() {
　　console.log('tick tock');
});
console.log('End of 1st loop');
```

## 子进程

node提供了child_process模块，允许你为主进程创建子进程

```javascript
let cp = require('child_process');

cp.exec('ls', function(e, stdout, stderr){
	if(e){
		console.log(e);
		console.log('-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*');
		console.log(stderr);
	}
	console.log(stdout);	
});
```

```javascript
var options = { 
    encoding: 'utf8',
    timeout: 0,
    maxBuffer: 200 * 1024,
    killSignal: 'SIGTERM',
    setsid: false,
    cwd: null,
    env: null 
};


var cp = require('child_process');
cp.exec('ls -l', options, function(e, stdout, stderr) {
　　if(!e) {
　　　　console.log(stdout);
　　　　console.log(stderr);
　　}
});
```

|            |                                 |
| :--------: | :-----------------------------: |
|  encoding  |            I/O流的编码格式            |
|  timeout   |             进程超时时间              |
| killSignal |       当时间或者缓冲区超限时终止进程的信号        |
| maxBuffer  |      stdout或stderr可增长的最大值       |
|   setsid   |        决定在进程中是否创建一个新的会话         |
|    cwd     | 进程的初始工作目录，为null时表示使用node的当前工作目录 |
|    env     |             进程的环境变量             |

```javascript
var cp = require('child_process');
var cat = cp.spawn('cat');
cat.stdout.on('data', function(d) {
　　console.log(d.toString());
});
cat.on('exit', function() {
　　console.log('kthxbai');
});
cat.stdin.write('meow');
cat.stdin.end();
```

## 接受信号

```javascript
process.stdin.resume();
process.on('SIGINT', function () {
    console.log('Got SIGINT, Press CTRL_D exit.');
});
```

## 属性

* process.stdin	//标准输入
* process.stdout //标准输出
* process.stderr //标准错误

```javascript
process.stdin.setEncoding('utf8');  //设置编码

process.stdin.on('readable', function () {  //标准输入
    var chunk = process.stdin.read();
    if (chunk !== null){
        process.stdout.write('data:'+chunk);
    }
});


process.stdin.on('end', function () {
    process.stdout.write('end');
});
```

## process.argv

````javascript
var argv = process.argv
console.log(argv)

node test 01 02 03

/*
[ 'D:\\dev\\nodejs\\node.exe',
  'D:\\phpStudy\\WWW\\node\\test',
  '01',
  '02',
  '03' ]
*/
process.argv.slice(2) //获得参数
````

简单使用

```javascript
var argvs = process.argv.slice(2);
switch (argvs[0]) {
	case 'init':
		console.log('正在初始化');
		break;
	case 'start':
		console.log('开始执行')
		break;
	case 'stop':
		console.log('执行已经停止');
		break;
	case 'restart':
		console.log('重启中...');
		break;
	default:
		console.log('未知命令');
		break;
}
```

## process.env

系统的环境变量

## process.stdin和process.stdout

即标准输入和标准输出

````javascript
//输出
process.stdout.write('向控制台输出内容\n');	//向输出流中写

//输入
//有数据流入
process.stdin.on('data', (data)=>{
	process.stdout.write(data);
});
````

## 符动画

[图转字符画](http://www.degraeve.com/img2txt.php)

```javascript
/*var fs = require('fs');*/
var frames = [];
frames[frames.length] = `╭~~~╮
(o^.^o)
`;
frames[frames.length] = `╭~~~╮
(o~.~o)
`;
frames[frames.length] = `╭~~~╮
(o@.@o)
`;
frames[frames.length] = `╭~~~╮
(o'.'o)
`;

/*for (var i = 1; i < 7; i++){
	frames[frames.length] = fs.readFileSync(`./frames/${i}.txt`, 'utf8');
}*/


// 帧率
var fps = 5;
// 当前被显示的帧
var index = 0;
var render = () =>{
	//将当前控制台清空
	/*直接清空控制台*/
	process.stdout.write('\033[2J');
	process.stdout.write('\033[0f');


	/*//windows命令行窗口大小
	var height = process.stdout.getWindowSize()[1];

	//将原有视图区往上顶
	for (var i = 0; i<heightcls
	; i++){
		process.stdout.write('\r\n');
	}*/

	//超过动画数量重置index
	index = (index==frames.length)?0:index;
	//并输出新的东西
	process.stdout.write(frames[index++]);
};

setInterval(render, 1000/fps);
```

## 调试

第三方调试工具

`npm install node-inspector -g`

`npm isntall devtool -g`

## 两次`CTRL+C` 取消执行

```javascript
setInterval(function(){
	console.log('1');
},1000);

//是否已经按过一次CTRL+C
var exiting = false;

process.on('SIGINT', ()=>{
	if(exiting){
		process.exit();
	} else {
		console.log('请再按一次')
		exiting = true;

		//清除长时间之前的操作
		setTimeout(()=>{
			exiting = false;
		}, 2000);
	}
});
```

## 方法

* process.cwd()	//返回脚本运行的工作目录
* process.chdir() //切换工作目录
* process.exit() //退出当前进程
* process.on() //添加监听事件

## 子进程

#### 通过child_process创建子进程

```javascript
var spawn = require('child_process').spawn,
    ls = spawn('ls', ['-lh', './']);

ls.stdout.on('data', function (data) {
    console.log('stdout:' + data);
});

ls.stderr.on('data', function (data) {
    console.log('stderr:' + data);
});

ls.on('close', function (code) {
    close.log('child process exited with code'+ code);
});
```

#### 在shell中运行一个命令，并缓存其输出

```javascript
var exec = require('child_process').exec,child;

child = exec('cat *.js bad_file | wc -l', function (error, stdout, stderr) {
    console.log('stdout:' + stdout);
    console.log('stderr:' + stderr);
    if(error !== null){
        console.log('exec error:' + error);
    }
});
```

#### 执行特定程序文件

```javascript
var child_process = require('child_process');

child_process.exec('ls -lh /usr', function (error, stdout, stderr) {
    console.log(stdout);
    console.log('*******************');
});

child_process.execFile('/bin/ls', ['-lh', '/usr'], function (error, stdout, stderr) {
    console.log(stdout);
});
```

#### 进程间通信

```javascript
//// main.js
var cp = require('child_process');

var n = cp.fork(__dirname + 'sub.js');
n.on('message', function (m) {
    console.log('PARENT got message:', m);
});

n.send({hello: 'world'});
```

```javascript
// sub.js
process.on('message', function(m) {
  console.log('CHILD got message:', m);
});

process.send({ foo: 'bar' });
```

#### cluster模块用于创建共享服务器端口的子进程

```javascript
var cluster = require('cluster');
var http = require('http');
var numCPUs = require('os').cpus().length;  //获得CPU内核数
console.log(numCPUs);

//master是主进程
if(cluster.isMaster){   //判断是否是master进程
    //根据内核数目创建worker进程
    for (var i = 0; i < numCPUs; i++){
        cluster.fork();
    }

    Object.keys(cluster.workers).forEach(function (id) {
        console.log(id);
        console.log('I am running with ID:' + cluster.workers[id].process.pid);
    });

    cluster.on('exit', function (worker, code, signal) {
        console.log('Worker ' + worker.process.pid + ' died')
    });
} else {
    //说明当前进程是worker进程
    http.createServer(function (req, res) {
        res.writeHead(200);
        res.end('Hello world\n');
    }).listen(8000);
}
```

在终端会看到根据CPU内核数创建的子进程信息。每个worker进程都是通过child_process.fork()方法产生的，所以它们可以通过IPC（进程间通信）与master进程通信。cluster.worker是worker进程对象，其中有 `worker.id`、`worker.process`等属性，还有`worker.send()`等方法。

## 与进程进行交互

|                 属性                 |                    含义                    |
| :--------------------------------: | :--------------------------------------: |
|          process.version           |              包含当前node实例的版本号              |
|       process.installPrefix        |                  包含安装路径                  |
|          process.platform          |             列举node运行的操作系统的环境             |
|          process.uptime()          |              包含当前进程运行的时长（秒）              |
| process.getgid(), process.setgid() |              获取或者设置group id              |
| process.getuid(), process.setuid() |              获取或者设计user id               |
|            process.pid             |                  获取进程id                  |
|           process.title            |                  设置进程名称                  |
|          process.execPath          |              当前node进程的执行路径               |
|           process.cwd()            |                  当前工作目录                  |
|       process.memoryUsage()        | node进程内存的使用情况，rss代表ram的使用情况，vsize代表总内存的使用大小，包括ram和swap |
| process.heapTotal,process.heapUsed |             v8引擎内存分配和正在使用的大小             |













