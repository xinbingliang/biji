#文件操作
####文件打开和读取

`fs.read(fd, buffer, offset, length, position, callback)`

- `fd`是文件描述符，必须接收`fs.open()`方法中的回调函数返回的第二个参数；
- `buffer`是存放读取到的数据的Buffer对象；
- `offset`指定向buffer中存放数据的起始位置；
- `length`指定读取文件中数据的字节数；
- `position`指定在文件中读取文件内容的起始位置；
- `callback`是回调函数，回调函数的参数：
  - `err`用于抛出异常；
  - `bytesRead`是从文件中读取内容的实际字节数；
  - `buffer`是被读取的缓存区对象。



```javascript
var fs = require('fs');
var buffer = new Buffer(1024);

//打开文件
function openFile() {
    fs.open('data.txt', 'r+',function (err, fd) {
        //发生错误，告知并退出
        if(err){
            console.log('打开文件失败');
            return;
        }

        //读取数据
        fs.read(fd, buffer, 0, buffer.length, 0, function (err, bytes) {
            //文件读取错误退出
            if(err){
                console.log('文件读取错误');
                return;
            }
            //有数据才读出
            if(bytes){
                console.log(buffer.slice(0, bytes).toString());
            }
        })
    })
}

openFile();
```
####文件读取
```javascript
fs.readFile('./test.js', {encoding: 'utf-8', flag:'r'}, function (error, data) {
    console.log(data);
});
```

```javascript
fs.readFile('./log.txt', function (err, data) {
    if(err){
        console.log('出错');
        return;
    }
    console.log(data.toString());
});
```

####文件存在性检测

```javascript
fs.exists('./test.js', function (bool) {
    if(bool){
        console.log('存在');
    }else{
        console.log('不存在');
    }
});
console.log(fs.existsSync('./test.js'));
```

####文件相关信息获取
```javascript
//获得文件信息
function getStats() {
    console.log('获得文件信息');
    fs.stat('data.txt', function (err, stats) {
        if(err){
            console.log(err);
            return;
        }
        console.log(stats);
        console.log(stats.isFile());
        console.log(stats.isDirectory());
    })
}
getStats();
```
####数据写入文件
```javascript
var fs = require('fs');
var buffer = new Buffer(1024);

function writeFile() {
    fs.open('data.txt', 'w+', function (err, fd) {
        if(err){
            console.log('文件打开失败！');
            return;
        }

        var data = "辛丙亮辛丙亮辛丙亮辛丙亮辛丙亮";
        buffer.write(data);

      	//fs.write(fd, buffer, offset, length, position, callback)
        fs.write(fd, buffer, 0, data.length, 0, function (err, bytes) {
            if(err){
                console.log('数据写入失败！');
                return;
            }
            console.log('写入数据量:'+bytes)
        })
    })
}

writeFile();

fs.writeFile('./log.txt', '辛丙亮', {encoding: 'utf-8', flag:'w'},function (error) {
    if(error){
        console.log(error.message);
    } else {
        console.log('文件写入成功!');
    }
});

//追加写
fs.appendFile('./log.txt', '\nword, 你好!', {encoding: 'utf-8'}, function (error) {
    if(error){
        console.log(error.message)
    }else{
        console.log('追加写入成功');
    }
});
```

####文件资源关闭
```javascript
function closeFile() {
    fs.open('data.txt', 'w+', function (err, fd) {
        if(err){
            console.log('文件打开失败！');
            return;
        }

        fs.close(fd, function (err) {
            if(err){
                console.log(err.stack);
                return;
            }
            console.log('文件已经关闭');
        })
    })
}

closeFile();
```
####文件删除
	fs.unlink('hello.js', function (err) {
	    if(err){
	        console.log('文件删除失败');
	    } else {
	        console.log('文件删除成功');
	    }
	})
####清空文件
```javascript
fs.open('client.js', 'r+', function(err,fd) {
    fs.ftruncate(fd, function(err) {
        if (err) console.log(err.stack);
        console.log("File truncated!");
    });
});
```

#### 目录读取

```javascript
//打印当前目录
'use strict';
const fs = require('fs');
const files = fs.readdirSync('.');
for(let fn in files){
    console.log(files[fn]);
}
```

```javascript
//命令行打印指定目录
'use strict';
const fs = require('fs');
let dir = '.';
//命令行有第二个参数的时候
if(process.argv[2]){
    dir = process.argv[2];
}
var files = fs.readdirSync(dir);
for (let fn in files){
    console.log(files[fn]);
}
```

####创建目录

```javascript
fs.mkdir('xin', function (err) {
    if(!err){
        console.log('目录创建成功！');
        return;
    }

    if(err && err.code === 'EEXIST'){
        console.log('您要创建的文件已经存在');
    } else {
        console.log(err.stack);
    }
});
```
####删除目录
```javascript
fs.rmdir('xin', function (err) {
    if(!err){
        console.log('移除目录成功！');
        return;
    }

    console.log('删除目录失败');
});
```
####对文件操作监听
```javascript
fs.watch('data.txt', function (event, filename) {
    console.log('event is: ' + event);
});
```
### 文件监视做Markdown自动转化

```javascript
'use strict';
const fs = require('fs');
const path = require('path');
const marked = require('marked');

// 接收需要转换的文件路径
const target = path.join(__dirname, process.argv[2] || 'README.md');

//监视文件变化
fs.watchFile(target, {interval: 200},(curr, prev)=>{
	//console.log(`current:${curr.size};previous:${prev.size}`);
	//文件大小和文件内容没有变化时
	if(curr.mtime === prev.mtime){
		//没有变化
		return false;
	}
	//读取文件转化为HTML
	fs.readFile(target, 'utf8',(err, content)=>{
		if(err){
			throw err;
		}
		//npm install marked
		//可以在网页中使用
		let html = marked(content);

		//ctrl+e
		var temple = `<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
<body>
	{{{content}}}
</body>
</html>`;

		html = temple.replace('{{{content}}}', html);
		fs.writeFile(target.replace('.md', '.html'), html, 'utf8');
	})
});
```

- 使用`github`的`markdown css`样式

## 自动打开浏览器并刷新

- 安装`npm install browser-sync`
- 需要`python27`的环境(此时可以不需要)

```javascript
'use strict';
const fs = require('fs');
const path = require('path');
const marked = require('marked');
const browerSync = require("browser-sync");

// 接收需要转换的文件路径
const target = path.join(__dirname, process.argv[2] || 'README.md');

let filename = target.replace('.md', '.html');
let indexpath = path.basename(filename);

//通过browerSync创建文件服务器,html在的位置
browerSync({
    notify: false,
	server:"./",
	index: indexpath	//自动打开该主文件
});

browerSync.reload("core.css");


//监视文件变化
fs.watchFile(target, (curr, prev)=>{
	//console.log(`current:${curr.size};previous:${prev.size}`);
	//文件大小和文件内容没有变化时
	if(curr.mtime === prev.mtime){
		//没有变化
		return false;
	}
	//读取文件转化为HTML
	fs.readFile(target, 'utf8',(err, content)=>{
		if(err){
			throw err;
		}
		//npm install marked
		//可以在网页中使用
		let html = marked(content);

		//ctrl+e
		var temple = `<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
<body>
	{{{content}}}
</body>
</html>`;

		html = temple.replace('{{{content}}}', html);
		
		fs.writeFile(filename, html, 'utf8', (err)=>{
			browerSync.reload(path.basename(filename));
		});
	})
});
```

## 文件流

- `fs.createReadStream()`得到一个`readableStream`
- `fs.createWriteStream()`得到一个`WritableStream`

### 大文件拷贝

`F2重命名`

```javascript
'use strict';
const fs = require('fs');
const path = require('path');

//创建流，但文件的读取流没有读出真的数据,开始文件读取的任务
console.time('start');
let file = 'C:\\Users\\Administrator.WIN7U-20161011H\\Desktop\\node\\4\\下午09-广播消息测试.web.mkv';
let reader = fs.createReadStream(file);

//创建写入流
let write = fs.createWriteStream('./1.mkv');

fs.stat(file, (error, stats)=>{
	if(error){
		return false;
	}

	let size = stats.size;
	let length = 0;
	//读取了一部分数据,就通知
	reader.on('data', (chunk)=>{
		//chunk就是buffer
		length += parseInt(chunk.length);
		/*17306813 */
		console.log('一丢丢：', (length/size)*100, '%');

		write.write(chunk, (error)=>{
			//做写入判断
		});
	})

	console.timeEnd('start');
});
```

- `github`上有个`node-fs-extra`包对文件操作的扩展

## pipe文件操作

```javascript
'use strict';
const fs = require('fs');
const path = require('path');

//创建流，但文件的读取流没有读出真的数据,开始文件读取的任务
console.time('start');
let file = 'C:\\Users\\Administrator.WIN7U-20161011H\\Desktop\\node\\4\\下午09-广播消息测试.web.mkv';
let reader = fs.createReadStream(file);
//创建写入流
let write = fs.createWriteStream('./1.mkv');

//进度监控,流入时触发
write.on('pipe', (src)=>{
	src.on('data', (chunk)=>{
		console.log(chunk.length);
	});
});

//pipe支持链式编程
reader.pipe(write);
```

## node-progress

`npm ls --depth 0` 当前文件夹下的包

`npm install progress`安装

```javascript
'use strict';

var ProgressBar = require('progress');

var bar = new ProgressBar('当前已经完成: :bar', { total: 80 , width: 20, complete: '*'});	//总长度，:bar是进度条占位,width表示展示数量
var timer = setInterval(function () {
  bar.tick();	//进度向下走
  if (bar.complete) {	//完成后
    console.log('\ncomplete\n');
    clearInterval(timer);
  }
}, 100);
```

- `total` 总长度
- `width` 显示长度，常用于计算
- `stream` the output stream defaulting to stderr
- `complete` completion character defaulting to "="
- `incomplete` incomplete character defaulting to "-"
- `renderThrottle` 渲染的帧16ms
- `clear` option to clear the bar on completion defaulting to false
- `callback` 完成后的回调

