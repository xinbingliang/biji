#Buffer缓冲器
缓冲区不能调整大小
##类方法
| 方法                                   | 参数                | 描述           |
| ------------------------------------ | ----------------- | ------------ |
| Buffer.isEncoding(encoding)          | 编码                | 编码测试         |
| BUffer.isBuffer(obj)                 | 对象                | 测试对象是否是缓冲区对象 |
| BUffer.byteLength(string[,encoding]) | 字符串，编码方式          | 该编码方式下的字符串长度 |
| BUffer.concat(list[, totaLength])    | 缓冲区对象列表，串联后的缓冲区大小 |              |
| BUffer.compare(buf1, buf2)           | 缓冲区对象             | 排序缓冲区对象      |

##使用实例
```javascript
var buffer = new Buffer(26);
console.log('缓冲区大小'+buffer.length);

var data = 'here comes everybody!';
buffer.write(data);
console.log(data+'的长度：'+data.length+',buffer区中的长度:'+Buffer.byteLength(data, 'utf8')+'bytes');

//截取缓冲区
var buffer1 = buffer.slice(0,14);
console.log("buffer1 length: " + buffer1.length);
console.log("buffer1 content: " + buffer1.toString());

//循环填充
for(var i = 0; i < 26; i++){
    buffer[i] = i + 97;
}
console.log(buffer.toString('ascii'));

//传入的是数组
var newbuffer = Buffer.concat([buffer1, buffer]);
console.log(newbuffer.toString());
```
##其他常用使用方法
####使用其他方式创建
```javascript
var buf = new Buffer([10, 20, 30, 40, 50]);
console.log(buf.toString());

var buf = new Buffer('here comes everybody!', 'utf-8');
console.log(buf.toString());
```
####向Buffer中写数据
```javascript
var buf = new Buffer(1024);
var len = buf.write('here comes everybody!');
console.log(len);
```
####数据读取
```javascript
buf.toString([encoding][, start][, end])
var buf = new Buffer(1024);
var len = buf.write('here comes everybody!');
console.log(buf.toString('utf8', 3, 12));
```
####缓冲到JSON
```javascript
var buf = new Buffer('here comes everybody!');
var json = buf.toJSON(buf);
console.log(json);
```
####比较缓冲器
```javascript
var buffer1 = new Buffer('ABC');
var buffer2 = new Buffer('ABCD');
var result = buffer1.compare(buffer2);

if(result < 0) {
    console.log(buffer1 +" comes before " + buffer2);
}else if(result == 0){
    console.log(buffer1 +" is same as " + buffer2);
}else {
    console.log(buffer1 +" comes after " + buffer2);
}
```
####复制缓冲器
buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])

* targetBuffer - 缓冲区对象的缓冲区将被复制。
* targetStart - 数量，可选，默认：0
* sourceStart - 数量，可选，默认：0
* sourceEnd - 数量，可选，默认：buffer.length

  ```javascript
  var buffer1 = new Buffer('ABC');

  var buffer2 = new Buffer(3);
  buffer1.copy(buffer2);
  console.log(buffer2.toString());
  ```
####切片式缓冲器
buf.slice([start][, end])

* start - 数量，可选，默认：0
* end - 数量可选，默认：buffer.length

  ```javascript
  var buffer1 = new Buffer('YiiBai');
  var buffer2 = buffer1.slice(0,9);
  console.log("buffer2 content: " + buffer2.toString());
  ```
####缓冲区长度
```javascript
var buffer = new Buffer('YiiBai');
console.log("buffer length: " + buffer.length);
```

## Buffer

读文件时，不指定编码，默认是buffer，即缓冲区

### Buffer转化为utf-8

```javascript
//该方法使用了Buffer但是却是一次性读取
fs.readFile(path.join(__dirname, 'data.lrc'), (error, data)=>{
	console.log(data.toString('utf8'));
});
```

### Buffer写

```javascript
let buffer = new Buffer(4);
buffer.write('123456', 'utf8');
console.log(buffer.toString('utf8'));

//做长度的截取
let buffer = new Buffer(4);
buffer.write('12', 'utf8');
console.log(buffer.toString('utf8', 0, 1));

//buffer接着写
let buffer = new Buffer(4);
buffer.write('12', 'utf8');
buffer.write('34', 2, 2, 'utf8')
console.log(buffer.toString('utf8'));
```

write写入的都是字符串

## 图片转base64

```javascript
'use strict';
const path = require('path');
const fs = require('fs');

//图片转Base64,读取图片，HTML5读图片
fs.readFile(path.join(__dirname, '1.png'), (error, data)=>{
	console.log(data.toString('base64'));	//base64编码最后都是==
});

/*data:image/png;base6,*/
```

## 文件编码问题

- 只能使用`UTF-8`编码
- 使用iconv-lite库

```javascript
'use strict';
const path = require('path');
const fs = require('fs');
const iconv = require('iconv-lite');

fs.readFile(path.join(__dirname, '1.txt'), (error, data)=>{
	console.log(data.toString());
	let str = iconv.decode(data, 'gbk');
	console.log(str);
});
```

## 流操作

```javascript
'use strict';
const path = require('path');
const fs = require('fs');
const iconv = require('iconv-lite');
const readline = require('readline');

const filename = path.join(__dirname, 'data.lrc');
//创建读取流
let readstream = fs.createReadStream(filename);

let data = '';
readstream.on('data', (chunk)=>{
	//chunk只是一部分数据
	data += chunk.toString('utf8');
});

//流读取结束
readstream.on('end', ()=>{
	console.log(data);
})
```

### 使用readline

```javascript
'use strict';
const path = require('path');
const fs = require('fs');
const iconv = require('iconv-lite');
const readline = require('readline');

const filename = path.join(__dirname, 'data.lrc');
//创建读取流
let readstream = fs.createReadStream(filename);
//GBK编码
//let readstream = fs.createReadStream(filename).pipe(iconv.decodeStream('gbk'));

//自动使用流去读取
let rl = readline.createInterface({input: readstream}); 

//每次读取的都是一行
rl.on('line', (line)=>{
	console.log(line);
})
```

## 文件写

```javascript
'use strict';
const fs = require('fs');
const path = require('path');

//序列化对象写入，写文件时不会创建文件夹，会覆盖原有数据
/*fs.writeFile(path.join(__dirname, 'xin.txt'), JSON.stringify({id:1}), (err)=>{
	if(err){
		console.log('error');
	} else {
		console.log('success');
	}
});*/

//追加写
fs.appendFile(path.join(__dirname, 'xin.txt'), JSON.stringify({id:1}), (err)=>{
	if(err){
		console.log('error');
	} else {
		console.log('success');
	}
});


/*fs.writeFileSync();*/

//以流的方式写，会追加写
/*var streamWrite = fs.createWriteStream(path.join(__dirname, 'xin.txt'));
//自动会转化为buffer
setInterval(()=>{
	streamWrite.write('dsfdsfdsfdsgdsgfdgfd', ()=>{
		console.log('+1');
})}, 1000)

*/
```

- `fs.stat(path, callback(error, stats)` 返回文件信息，常用于，文件存在检测，和`stats.isFile()`与`stats.isDirectory()`配合使用
- `fs.rename(oldPath, newPath)` 重命名文件或移动，使用绝对路径
- `fs.renameSync(oldPath, newPath)` 
- `fs.unlink(path, callback(err))` 删除文件
- `fs.unlinkSync(path)` 

```javascript
'use strict';
const fs = require('fs');
const path = require('path');

let ofilename = path.join(__dirname, 'xin.txt');
let nfiname = path.join(__dirname, 'xin.txt2');


fs.rename(ofilename, nfiname);
```

- `fs.mkdir()`创建目录
- `fs.mkdirSync()`
- `fs.rmdir()` 删除空目录
- `fs.rmdirSync()`
- `fs.readdir(path.callback())`读取目录
- fs.readdirSync(path)

### 文件夹操作

```javascript
'use strict';
const fs = require('fs');
const path = require('path');

let arr = fs.readdir(__dirname, (error, data)=>{
	data.forEach((file)=>{
		fs.stat(path.join(__dirname, file), (err, stats)=>{
			console.log(`${stats.mtime}\n`)
		})
	})
});
```






