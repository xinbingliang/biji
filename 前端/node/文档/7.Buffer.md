# Buffer

- `'ascii'` - 仅适用 7 bit ASCII 格式数据。这个编码方式非常快速，而且会剥离设置过高的bit。


- `'utf8'` - 多字节编码 Unicode字符。很多网页或者其他文档的编码格式都是使用 UTF-8的。


- `'utf16le'` - 2 或者 4 字节, Little Endian (LE) 编码Unicode字符。 代理对 (U+10000 to U+10FFFF) 是支持的.（BE和LE表示大端和小端，Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端；Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端；下同）


- `'ucs2'` - `'utf16le'`的别名.


- `'base64'` - Base64 字符串编码。


- `'binary'` - 一个将原始2进制数据编码为字符串的方法，仅使用每个字符的前8bits。 这个编码方式已经被弃用而且应该被避免，尽可能的使用`Buffer`对象。这个编码方式将会在未来的Node版本中移除。


- `'hex'` - 把每个byte编码成2个十六进制字符

## Buffer类

* new Buffer(size)  分配一个新的 buffer 大小是 `size` 的8位字节.

* new Buffer(array) 分配一个新的 buffer ，其中包含着给定的 `str`字符串. `encoding` 编码方式默认是：`'utf8'`

* new Buffer(str, [encoding])  分配一个新的 buffer ，其中包含着给定的 `str`字符串. `encoding` 编码方式默认是：`'utf8'`.

* 类方法: Buffer.isEncoding(encoding)

  ````javascript
  console.log(Buffer.isEncoding('utf8'));
  ````

* 类方法: Buffer.isBuffer(obj)  测试这个 `obj` 是否是一个 `Buffer`.

* 类方法: Buffer.byteLength(string, [encoding]) 将会返回这个字符串真实byte长度。 `encoding` 编码默认是： `'utf8'`. 这个和 `String.prototype.length` 是不一样的，因为那个方法返回这个字符串中有几个字符的数量。 当用户在写http响应头Cotent-Length的时候，千万记得一定要用 `Buffer.byteLength` 方法，

* 类方法: Buffer.concat(list, [totalLength]) 实就是将数组中所有的buffer实例通过复制拼接在一起

* buf.length 分配的buffer大小

* buf.write(string, [offset], [length], [encoding])

  ```javascript
  let buf = new Buffer(256);
  console.log('byteLength', buf.byteLength);
  console.log('length', buf.length);


  let len = buf.write('\u00bd + \u00bc = \u00be', 0);
  console.log(len + 'bytes:' + buf.toString('utf8', 0, len));
  ```

* buf.toString([encoding], [start], [end]) 根据 `encoding`参数（默认是 `'utf8'`）返回一个解码的 string 类型。还会根据传入的参数 `start` (默认是`0`) 和 `end` (默认是 `buffer.length`)作为取值范围。

* buf.toJSON() 返回一个 JSON表示的Buffer实例。`JSON.stringify`将会默认调用来字符串序列化这个Buffer实例

* buf[index] 获取或者设置在指定`index`索引位置的8位字节。这个值是指单个字节，所以这个值必须在合法的范围，16进制的`0x00` 到`0xFF`，或者`0` 到`255`。

* buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd]) 进行buffer的拷贝，源和目标可以是重叠的。 `targetStart` 目标开始偏移 和`sourceStart`源开始偏移 默认都是 `0`. `sourceEnd` 源结束位置偏移默认是源的长度 `buffer.length`.

* buf.slice([start], [end]) 返回一个新的buffer，这个buffer将会和老的buffer引用相同的内存地址，只是根据 `start` (默认是 `0`) 和`end` (默认是`buffer.length`) 偏移和裁剪了索引。 负的索引是从buffer尾部开始计算的。**修改这个新的buffer实例slice切片，也会改变原来的buffer**

* buf.fill(value, [offset], [end])  使用指定的value来填充这个buffer。如果 `offset` (默认是 `0`) 并且 `end` (默认是 `buffer.length`) 没有明确给出，就会填充整个buffer。

## buffer.INSPECT_MAX_BYTES

设置当调用`buffer.inspect()`方法后，多少bytes将会返回。

## 类:SlowBuffer

返回一个不被池管理的 `Buffer`

为了避免创建大量独立分配的 Buffer 带来的垃圾回收开销，默认情况下小于 4KB 的空间都是切割自一个较大的独立对象。