# 流-stream

* Readable 流
* Writeable 流
* Duplex 流
* Transform 流

## 面向流消费者的API

### 类：stream.Readable

Readable（可读）流接口是对您正在读取的数据的*来源*的抽象。

Readable 流有两种“模式”：**流动模式**和**暂停模式**。当处于流动模式时，数据由底层系统读出，并尽可能快地提供给您的程序；当处于暂停模式时，您必须明确地调用 `stream.read()` 来取出若干数据块。流默认处于暂停模式。

您可以通过下面几种做法切换到流动模式：

- 添加一个 [`'data'` 事件](http://www.nodeclass.com/api/node.html#stream_event_data)处理器来监听数据。
- 调用 [`resume()`](http://www.nodeclass.com/api/node.html#stream_readable_resume) 方法来明确开启数据流。
- 调用 [`pipe()`](http://www.nodeclass.com/api/node.html#stream_readable_pipe_destination_options) 方法将数据发送到一个 [Writable](http://www.nodeclass.com/api/node.html#stream_class_stream_writable)。

您可以通过下面其中一种做法切换回暂停模式：

- 如果没有导流目标，调用 [`pause()`](http://www.nodeclass.com/api/node.html#stream_readable_pause) 方法。
- 如果有导流目标，移除所有 [`'data'` 事件][] 处理器、调用 [`unpipe()`](http://www.nodeclass.com/api/node.html#stream_readable_unpipe_destination) 方法移除所有导流目标

*****

- 事件`readable` 当一个数据块可以从流中被读出时，它会触发一个 `'readable'` 事件。

- 事件`data` 绑定一个 `data` 事件监听器到一个未被明确暂停的流会将流切换到流动模式，数据会被尽可能地传递。

- 事件`end` 该事件会在没有更多数据能够提供时被触发。

- 事件`close` 当底层数据源（比如，源头的文件描述符）被关闭时触发。并不是所有流都会触发这个事件。

- 事件`error` 当数据接收时发生错误时触发。

- readable.read() `read()` 方法从内部缓冲区中拉取并返回若干数据。当没有更多数据可用时，它会返回 `null`。

- readable.setEncoding(encoding) 调用此函数会使得流返回指定编码的字符串而不是 Buffer 对象。

- readable.resume() 让流持续触发`data`事件。该方法会将流切换到流动模式。如果您*不想*从流中消费数据，但您*想*得到它的 `end` 事件，您可以调用 [`readable.resume()`](http://www.nodeclass.com/api/node.html#stream_readable_resume) 来启动数据流。

- readable.pause() 该方法会使一个处于流动模式的流停止触发 `data` 事件，切换到非流动模式，并让后续可用数据留在内部缓冲区中。

- readable.pipe(destination, [options])  该方法从可读流中拉取所有数据，并写入到所提供的目标

  ````javascript
  const fs = require('fs');
  const zlib = require('zlib');

  let r = fs.createReadStream('test.txt');
  let z = zlib.createGzip();
  var w = fs.createWriteStream('file.text.gz');
  r.pipe(z).pipe(w);
  ````

- readable.unpipe([destination])  `destination` {[Writable](http://www.nodeclass.com/api/node.html#stream_class_stream_writable) Stream} 可选，指定解除导流的流，该方法会移除之前调用 `pipe()` 所设定的钩子。如果不指定目标，所有导流都会被移除。

- readable.unshift(chunk) 

### 类：stream.Writable

Writable（可写）流接口是对您正在写入数据*至一个目标*的抽象。

* writable.write(chunk, [encoding], [callback]) 该方法向底层系统写入数据，并在数据被处理完毕后调用所给的回调。
  * `chunk` {String | Buffer} 要写入的数据
  * `encoding` {String} 编码，假如 `chunk` 是一个字符串
  * `callback` {Function} 数据块写入后的回调
  * 返回: {Boolean} 如果数据已被全部处理则 `true`。
* 事件`drain` 如果一个 [`writable.write(chunk)`](http://www.nodeclass.com/api/node.html#stream_writable_write_chunk_encoding_callback) 调用返回 `false`，那么 `drain` 事件则表明可以继续向流写入更多数据
* writable.cork() 强行滞留所有写入。滞留的数据会在 .uncork() 或 .end() 调用时被写入。
* writable.uncork() 写入所有 .cork() 调用之后滞留的数据。
* writable.end([chunk], [encoding], [callback]) 当没有更多数据会被写入到流时调用此方法。
  - `chunk` {String | Buffer} 可选，要写入的数据
  - `encoding` {String} 编码，假如 chunk 是一个字符串
  - `callback` {Function} 可选，流结束后的回调
* 事件'finish' 当 [`end()`](http://www.nodeclass.com/api/node.html#stream_writable_end_chunk_encoding_callback) 方法被调用，并且所有数据已被写入到底层系统，此事件会被触发。
* 事件: 'pipe' 该事件发生于可读流的 `pipe()` 方法被调用并添加本可写流作为它的目标时。
* 事件: 'unpipe'  该事件发生于可读流的 `unpipe()` 方法被调用并将本可写流从它的目标移除时。

### 类：stream.duplex

双工（Duplex）流同时实现了 [Readable](http://www.nodeclass.com/api/node.html#stream_class_stream_readable) 和 [Writable](http://www.nodeclass.com/api/node.html#stream_class_stream_writable) 的接口。

### 类：stream.Transform

转换（Transform）流是一种输出由输入计算所得的[双工](http://www.nodeclass.com/api/node.html#stream_class_stream_duplex)流。

## 面向流实现者的API

### 类：stream.Reable

### 类：stream.Writable

### writable.__writev()

### 类:stream.Duplex

### 类：stream.Transform

### 类: stream.PassThrough

## 流：内部细节


