#jsonp、postMessage、XMLHttpRequest Level2
##jsonp
这是一种跨域通信的策略，器本质是：

```javascript
function CreateScript(src) {
    $("<script><\/script>").attr('src', src).appendTo('body');
}

$('button').click(function () {
    CreateScript('http://www.xin.org/index.php');
})
```
我们都使用过CDN引入不同服务器上的js文件，那么jsonp就是利用这种策略，让浏览器误认为在请求js文件，通常我们不会这样底层的去写jsonp，而是使用jQuery提供好的方法。

```html
<script>
    $.ajax({
        type: "get",
        async: false,
        url: "http://localhost/index.php",
        dataType: "jsonp",
        jsonp: "callback",//&callback=&
        jsonpCallback:"myFun",//&callback=myFun&
        success: function(json){
            console.log(json);
        },
        error: function(){
            console.log('fail');
        }
    });
</script>
```

```php
$callback = $_GET['callback'];
$arr = array('name'=>'辛丙亮', 'age'=>'23');
echo $callback.'('.json_encode($arr).')';
```

### 实例

```html
<script>
    $.ajax({
        type: "get",
        async: false,
        url: "     http://api.asilu.com/bg/",
        dataType: "jsonp",
        jsonp: "callback",//&callback=&
        jsonpCallback:"myFun",//&callback=myFun&
        success: function(json){
            /*console.log(json);*/
            for (var index in json.images){
                var img = new Image();
                img.src = json.images[index].url;

                var div = $('<div></div>').append(img);
                div.append('<p>'+json.images[index].copyright+'</p>');
                $('section').append(div);
            }
        },
        error: function(){
            console.log('fail');
        }
    });
</script>
```

## 请求带参数

```javascript
$.ajax({
    type: "get",
    async: false,
    url: "http://api.asilu.com/weather/",
    dataType: "jsonp",
    jsonp: "callback",//&callback=&
    jsonpCallback:"myFun",//&callback=myFun&
    data: {city: '宜昌'},
    success: function(json){
        console.log(json);
    },
    error: function(){
        console.log('fail');
    }
});
```

##postMessage

这是一种即可以在同域不同页面间通信，又可以跨域通信的策略

### 不同域页面通信

```javascript
<!--域为bing.org-->
<body>
    <iframe id="child" src="http://www.xin.org/index.html">

    </iframe>
<button>按钮</button>
</body>
<script>
    $(function () {
        $('button').click(function () {
            window.postMessage('hello', 'http://www.xin.org/index.php');
        })
    })

    window.addEventListener('message',function(e){
        console.log(e.data);
    },false);
</script>
 
<!--域为xin.org-->
<script type="text/javascript">
window.addEventListener('message',function(e){
    window.parent.postMessage('ok','*');
},false);
</script>
```
### 同域页面通信

```html
<body>
    <section class="container">
        <iframe id="child" src="http://www.ng.com/home.html">

        </iframe>
        <button class="btn btn-primary">按钮</button>
    </section>
</body>
<script>
    $(function () {
        $('button').click(function () {
            var iframe = document.getElementById('child').contentWindow;
            iframe.postMessage('hello', 'http://www.ng.com/home.html');
        });
    });
    window.addEventListener('message', function (e) {
        console.log(e.data);
    }, false)
</script>
</html>
```

```html
<body>
    <h1>Home 页面</h1>
</body>
<script>
    window.addEventListener('message', function (e) {
        window.parent.postMessage('ok', '*');
    })
</script>
```

同域下不同页面通信是类似的，这种通信方式用在不同页面之间，并且在使用时一般都需要使用ifram引入

| 属性       | 值          |
| -------- | ---------- |
| e.data   | 传递发message |
| e.source | 发送消息的窗口对象  |
| e.origin | 发送消息的域     |

##XMLHttpRequest Level2
不用说就知道这是我们常用的ajax。新版的ajax增加了跨域通信、进度事件、二进制数据传递    
老版的用法：
```javascript
$(function () {
    $('button').click(function () {
        var xhr = new XMLHttpRequest();

        xhr.open('GET', 'index.php');
        xhr.send();

        xhr.onreadystatechange = function () {
            if(xhr.readyState == 4 && xhr.status == 200){
                alert(xhr.responseText);
            }else{
                alert(xhr.statusText);
            }
        }
    })
});
```

| 属性               | 说明                                 |
| ---------------- | ---------------------------------- |
| xhr.readyState   | XMLHttpRequest对象的状态，等于4表示数据已经接收完毕。 |
| xhr.status       | 服务器返回的状态码，等于200表示一切正常。             |
| xhr.responseText | 服务器返回的文本数据                         |
| xhr.responseXML  | 服务器返回的XML格式的数据                     |
| xhr.statusText   | 服务器返回的状态文本。                        |

##使用表单

```javascript
$(function () {
    $('button').click(function () {
        var xhr = new XMLHttpRequest();

        xhr.timeout = 3000;

        xhr.ontimeout = function (event) {
            alert("请求超时");
        };

        //新建表单上传数据
        var formData = new FormData();
        formData.append('username', '张三');
        formData.append('id', 123456);

        xhr.open('POST', 'index.php');
        xhr.send(formData);

        xhr.onreadystatechange = function () {
            if(xhr.readyState == 4 && xhr.status == 200){
                alert(xhr.responseText);
            }else{
                alert(xhr.statusText);
            }
        }
    })
});
```

##上传文件
```javascript
<body>
    <input type="file" name="file"/>
    <button>按钮</button>
</body>
<script>
$(function () {
    $('button').click(function () {
        var xhr = new XMLHttpRequest();

        xhr.timeout = 3000;

        xhr.ontimeout = function (event) {
            alert("请求超时");
        };

        //新建表单上传数据
        var formData = new FormData();
        xhr.open('POST', 'index.php');
        xhr.send(formData);

        var file = $('input')[0];
        formData.append('files[]', file);

        xhr.onreadystatechange = function () {
            if(xhr.readyState == 4 && xhr.status == 200){
                alert(xhr.responseText);
            }else{
                alert(xhr.statusText);
            }
        }
    })
});
</script>
```
##请求二进制数据
```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', 'weather.png');
xhr.responseType = 'blob';

xhr.send();

xhr.onreadystatechange = function () {
    if(xhr.readyState == 4 && xhr.status == 200){
        var blob = new Blob([xhr.response], {type: 'image/png'});
        console.log(blob);
    }else{
        alert(xhr.statusText);
	}
}
```
```html
<script>
    $(function () {
        $('button').click(function () {
            var xhr = new XMLHttpRequest();

            xhr.timeout = 3000;

            xhr.ontimeout = function (event) {
                console.log('请求超时');
            };

            xhr.open('GET', '1.jpg');
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
            /*xhr.responseType = 'blob';*/
            xhr.send();

            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4 && xhr.status == 200){
                    var binStr = xhr.responseText;

                }else {
                    console.log(xhr.statusText);
                }
            }
        });
    });
</script>
```

将请求的数据放进二进制数组

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', 'weather.png', true);

xhr.responseType = "arraybuffer";
xhr.onload = function () {
    var arrayBuffer = xhr.response;

    if(arrayBuffer){
        var byteArray = new Uint8Array(arrayBuffer);
        for (var i = 0; i < byteArray.byteLength; i++) {

        }
    }
}

xhr.send();
```

##进度消息
下载的事件
xhr.onprogress = updateProgress;
上传的事件
xhr.upload.onprogress = updateProgress;    

```javascript
function updateProgress(event) {
	if (event.lengthComputable) {

		var percentComplete = event.loaded 或event.total;

	}

}
```

| 事件                     | 含义                                       |
| ---------------------- | ---------------------------------------- |
| event.total            | 需要传输的总字节                                 |
| event.loaded           | 已经传输的字节                                  |
| event.lengthComputable | event.lengthComputable不为真，则event.total等于0 |
| load事件                 | 传输成功完成。                                  |
| abort事件                | 传输被用户取消。                                 |
| error事件                | 传输中出现错误。                                 |
| loadstart事件            | 传输开始。                                    |
| loadEnd事件              | 传输结束，但是不知道成功还是失败。                        |


















