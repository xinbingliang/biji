# 正则

## 模式

### 通配符

* `. `任意字符
* `^` 开头
* `$` 结尾
* `*` 0~n
* `+` 1~n
* `?` 0 or 1
* `{n}`个数
* []集合中的任意一个

```python
print(re.search(r'(0[xX][0-9a-fA-F]{6})', 'The hex value is 0xFF03D6').groups())
```

```python
import re

def re_pattern_syntax():
    # print(re.match(r'.*', 'abc\nedf', re.DOTALL).group())   # 换行就结束，换行也被匹配
    # print(re.findall(r'^abc', 'abc\nabc', re.MULTILINE))    # 处理第一个换行，处理多行
    print(re.findall(r'abc\d$', 'abc1\nabc2', re.MULTILINE)) # 一般情况表示字符串的结束,之后可以换行当作结尾

if __name__ == '__main__':
    re_pattern_syntax()
```

### 贪婪和非贪婪

```python
import re

def re_pattern_syntax():
    s = '<h1>title</h1>'
    print(re.match(r'<.+>', s).group()) #<h1 >title</h1 > 形成贪婪模式了
    print(re.match(r'<.+?>', s).group()) # 非贪婪模式

if __name__ == '__main__':
    re_pattern_syntax()
```

### 特殊通配符

* `\n` 前一个匹配组

```python
import re

def re_pattern_syntax_meta_char():
    print(re.search(r'(\d)(\d)(\d)\1\2\3', '135135').groups()) #('1', '3', '5')

if __name__ == '__main__':
    re_pattern_syntax_meta_char()
    
    print(re.search(r'(\d{3}) \1', '135 135').groups()) #('1', '3', '5')
```

* `\d` 数字
* `\D` 任意的非数字字符
* `\b` 匹配单词开头和结尾
* `\s` 空格【\t\n\r\f\v】\f 换页 \v垂直制表符
* `\S ` 非空格

```python
print(re.match(r'Name\s*:\s*([a-zA-Z]+)', 'Name: \tJoey').groups())
```

* \w [a-zA-Z0-9]
* \W
* `re.I/re.IGNORECASE` 忽略大小写 

````python
import re

def re_pattern_flags():
    print(re.match(r'(Name)\s*:\s*(\w+)', 'Name: Joey', re.IGNORECASE).group())

if __name__ == '__main__':
    re_pattern_flags()
````

### RegexObject

创建正则表达式，并加注释

```python
import re

def re_pattern_flags():
    s = 'the number is 20.5'
    r = re.compile(r'''
                    \d+         # 整数部分
                    \.?         # 小数点，可能包含也可能不包含
                    \d*         # 小数部分可选
                    ''', re.VERBOSE)
    print(r.search(s).group())

if __name__ == '__main__':
    re_pattern_flags()
```

可以在对以上正则编译,re.compile()返回结果

* `search()`
* `match`
* `findall`
* `split`
* `finditer`
* `sub`

## 方法

### search

搜索字符串，找到匹配的第一个字符串

### match

从字符串开始开始匹配，遇到换行结束

```python
# -*- coding:utf-8 -*-
import re

def re_dome():
    # 解析出价格
    txt = 'If you purchase more than 100 sets, the price of product A is $9.90'
    # 解析数量和价格：pattern/string/MatchObject
    m = re.search(r'(\d+).*\$(\d+\.?\d*)', txt)
    print(m.groups())

if  __name__ == '__main__':
    re_dome()
```

**search搜索字符串任意位置匹配**

**match只从字符串开始位置进行匹配**

```python
def re_method():
    s = 'abcd'
    print(re.search(r'c', s))   # _sre.SRE_Match object at 0x0000000002681440>
    print(re.match(r'c', s))    # None
    # match表示匹配字符串开头为c的
    print(re.search(r'^c', s)) # 严格以c开头
    print(re.match(r'.*c', s))
    

if  __name__ == '__main__':
    re_method()
```

### split

使用正则表达式来分割字符串

```python
def re_method():
    s = 'This is Joey Huang'
    print(re.split(r'\W', s));

if  __name__ == '__main__':
    re_method()
```

### findall

根据正则表达式从左到右搜索匹配项，返回匹配的字符串列表

```python
def re_findall():
    s = 'Hello, this is Joey'
    print(re.findall(r'\w+', s))

if  __name__ == '__main__':
    re_findall()
```

### finditer

根据正则表达式从左到右搜索匹配项，返回一个迭代器迭代返回`MatchObject`

* `re.MatchObject`

  * group() 返回匹配的组

    * 索引0表示全部匹配的字符串
    * 索引1开始表示匹配的子组
    * 参数可以一个也可以多个
    * 命名组

    ```python
    m.group(0)
    ```

  * groupdict() 返回命名组的字典

  * groups() 返回匹配的子组，索引从1开始的所有子组

  * start/end/span 返回匹配的位置

```python
def re_finditer():
    s = 'The first price is $9.90 and second price is $100'
    i = re.finditer(r'\d+\.?\d*', s)
    for m in i:
        print(m.group())

if  __name__ == '__main__':
    re_finditer()
```

### sub

字符串的替换

* pattern 正则表达式
* repl 替换项，字符串或函数
* string 待处理的字符串

```python
def re_sub():
    s2 = 'The first price is $9.90 and second price is $100'
    print(re.sub(r'\d+\.?\d*', '<number>', s2))

if  __name__ == '__main__':
    re_sub()
```

### subn

和sub一样，返回值多了替换字符串个数

```python
def re_sub():
    s2 = 'The first price is $9.90 and second price is $100'
    print(re.subn(r'\d+\.?\d*', '<number>', s2))

if  __name__ == '__main__':
    re_sub()
```

