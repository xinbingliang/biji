# 多线程

* 原子操作

## 线程同步

1.锁

* `aquire` 上锁
* `release` 解锁
* `threading.Lock`  不论是谁必须有钥匙才能进入
* `threading.RLock` 同一类可以进入

2.信号量

* `threading.Semaphore` 多配钥匙
* `init_value` 多少钥匙

3.条件

* `threading.Condition`  
* `wait` 锁住之后才能等待，会自动释放锁
* `notify` 通知第一个排队等待的
* `notify_all` 通知所有排队的

4.事件

* 通知所有人
* 没有锁机制

## 简单爬虫

```python
import threading
import time
import random

def worker_func():
    print('当前线程的名称：%s' % threading.current_thread())
    random.seed()
    time.sleep(random.random()) # 随机睡眠一段时间
    print('完成任务的线程名称：%s' % threading.current_thread())

def simple_thread_demo():
    for i in range(10):
        threading.Thread(target=worker_func).start()


if __name__ == '__main__':
    simple_thread_demo()
```

## 一段时间内只有一个线程在执行其他等待

```python
# -*- coding:utf-8 -*-
import threading
import time
import random

def worker_func():
    print('当前线程的名称：%s' % threading.current_thread())
    random.seed()
    time.sleep(random.random()) # 随机睡眠一段时间
    print('完成任务的线程名称：%s' % threading.current_thread())

# 线程安全代码
def worker_func_lock(lock):
    lock.acquire()
    worker_func()
    lock.release()

#定义锁
gLock = threading.Lock()

def thread_demo_lock():
    for i in range(10):
        threading.Thread(target=worker_func_lock, args=[gLock]).start()

if __name__ == '__main__':
    thread_demo_lock()
```

## 信号量（同时允许多个线程执行）

````python
# -*- coding:utf-8 -*-
import threading
import time
import random

def worker_func():
    print('当前线程的名称：%s' % threading.current_thread())
    random.seed()
    time.sleep(random.random()) # 随机睡眠一段时间
    print('完成任务的线程名称：%s' % threading.current_thread())

# 线程安全代码
def worker_func_lock(lock):
    lock.acquire()
    worker_func()
    lock.release()

#定义锁
# gLock = threading.Lock()

# 信号量
gSem = threading.Semaphore(3)

def thread_demo_lock():
    for i in range(10):
        threading.Thread(target=worker_func_lock, args=[gSem]).start()

if __name__ == '__main__':
    thread_demo_lock()
````

## 金库的例子

```python
gMoney = 1000   # 原始金额
gCondition = threading.Condition()  # 条件

# 生产者
class Producer(threading.Thread):
    # 生产者线程的主函数
    def run(self):
        print('%s is start' % threading.current_thread())
        while True:
            global  gMoney
            global  gCondition

            gCondition.acquire()    # 上锁
            random.seed()
            p = random.randint(100, 500)
            gMoney += p
            print('生产 %s;总共 %s' % (p, gMoney))
            time.sleep(random.random()) # 随机延时
            gCondition.notify_all() # 通知所有人
            gCondition.release()    # 释放锁


# 消费者
class Consumer(threading.Thread):
    def run(self):
        print('%s is start' % threading.current_thread())
        while True:
            global gMoney
            global gCondition

            gCondition.acquire()    # 添加锁
            random.seed()
            c = random.randint(500, 1000)
            while gMoney < c:
                gCondition.wait()   # 少于金额则等待

            gMoney -= c
            print('消费 %s;剩余 %s' % (c, gMoney))
            time.sleep(random.random())
            gCondition.release()    # 释放锁


def consumer_producer_demo():
    for i in range(1):
        Consumer().start()

    for i in range(1):
        Producer().start()


if __name__ == '__main__':
    consumer_producer_demo()
```













