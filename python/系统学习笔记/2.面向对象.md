# 面向对象

## 定义

```python
class Cat:
    def talk(self):
        pass

    def eat(self):
        pass
    
cat = Cat();
```

* 即便在类中没有定义属性，也可以直接给对象添加，self作用是传递当前调用对象本身

## 魔术方法

* `__init__(self)`

```python
class Cat:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):
        print("名字：%s---年龄：%s" % (self.name, self.age))
    
cat = Cat('辛丙亮', '24');
cat.talk()
```

* `__str__(self)`

  定义对象描述信息

* `__del__`

  析构方法

## 私有方法

```python
class Cls:
    def __func():
        print('-----')

obj = Cls();
obj.__func()
```

* `sys.getrefcount()` 获得对象引用计数，比实际个数多一

## 继承

```python
class Animal:
	pass

class Dog(Animal):
	pass
```

父类的父类功能也是能继承

```python
class Dog:
	def bark(self):
		print('....')
		
class xiaotianquan(dog):
	def bark(self):
		Dog.brk(self) #super.bark()
		print('#####')
```

### 多继承

````python
class A(object):
	def test(self):
		print('====A')

class B(object):
	def test(self):
		print('====B')

class C(A, B):
````

* `A.__mro__` 打印继承的元组，表示了搜索的过程

## 多态

```python
def A(object):
	def test(self):
		pass
		
def B(object):
	def test(self):
		pass
		
def handle(obj):
	obj.test()
```

## 类属性

```python
class Tool(object):
    count = 0	#类属性
    
    def __init__(self, name)
    	count += 1
```

会导致某个对象对类属性修改，其他读取也会修改，即对象间共享

## 类方法

```python
class Game(object):
    num = 0	#类属性
    
    #类方法
    @classmethod
    def add(cls):
        cls.num += 1
    
	def __init__(self):
		self.name = '老王'

game = Game()
Game.add()
game.add() #对象调用类方法

print(Game.num)
```

## 静态方法

```python
class Game(object):
    num = 0	#类属性
    
    #类方法
    @staticmethod
    def add():
        cls.num += 1
    
	def __init__(self):
		self.name = '老王'

game = Game()
Game.add() #类调用静态方法	
game.add() #对象调用静态方法

print(Game.num)
```

当方法和实例无关和类也无关时定义



