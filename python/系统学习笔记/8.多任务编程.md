# 多任务编程

**调度算法方式**

* 时间片轮转
* 优先级调度

**概念**

* 并发 任务有部分被执行
* 并行 任务都被执行

## 进程

* 编码完毕在没运行时是程序
* 当程序运行并拥有的资源环境叫进程

### fork(子进程)

```python
# windows不支持
import os 
import time


ret = os.fork()
if ret == 0: # 子进程
    while True:
        print('--1--')
        time.sleep(3)
else:	#主（父）进程
    while True:
        print('--2--')
        time.sleep(3)
```

### getpid、getppid()

* `getpid()` 进程id
* `gitppid()` 父进程id

```python
import os 
import time

ret = os.fork()
print('main')	#父子进程都执行

if ret > 0:
    print('--父进程--%d'%os.getpid())
else:
    print('--子进程--%d--%d'%(os.getpid(), os.getppid()))
```

###主进程子进程结束

```python
import os 
import time

ret = os.fork()
if ret == 0:
    print('---子进程---start')
    time.sleep(5)
    print('---子进程---end')
else:
    print('----父进程---start')
    time.sleep(3)
    print('---父进程---end')

print('----over----')
```

进程退出彼此没有关系

### 变量共享

父进程和子进程之间变量不共享

```python
import os
import time

g_num = 100

ret = os.fork()
if ret==0:
    print("子进程")
    g_num += 1
    print('g_num = %d' % g_num)	
else:
    time.sleep(3)
    print('父进程')
    print('g_num = %d ==' % g_num)
```

### 多个fork

```python
import os
import time

g_num = 100

ret = os.fork()
if ret==0:
    print('---1---')
else:
    print('---2---')


ret = os.fork()
if ret==0:
    print('---1---')
else:
    print('---2---')
    
'''
---2---
---1---
---2---
---2---
---1---
---1---
'''
```

**fork炸弹**

```python
import os
while True:
    os.fork()
```

##multiprocessing

### process([group [, target [, name [, args [, kwargs]]]]])

- target：表示这个进程实例所调用对象；
- args：表示调用对象的位置参数元组；
- kwargs：表示调用对象的关键字参数字典；
- name：为当前进程实例的别名；
- group：大多数情况下用不到；

类常用方法：

- is_alive()：判断进程实例是否还在执行；
- join([timeout])：是否等待进程实例执行结束，或等待多少秒；
- start()：启动进程实例（创建子进程）；
- run()：如果没有给定target参数，对这个对象调用start()方法时，就将执行对象中的run()方法；
- terminate()：不管任务是否完成，立即终止；

类常用属性：

- name：当前进程实例别名，默认为Process-N，N为从1开始递增的整数；
- pid：当前进程实例的PID值；

```python
from multiprocessing import Process
import time

def test():
    while True:
        print("---test---")
        time.sleep(1)

p = Process(target=test) # target指定执行的代码
p.start() #新进程开始执行

while True:
    print('---main---')
    time.sleep(1)
```

此时主进程并不会因为执行完成后就退出

```python
import time

def test():
    while True:
        print("---test---")
        time.sleep(1)

p = Process(target=test)
p.start()
```

**join()**

````python
from multiprocessing import Process
import time

def test():
    for x in range(10):
        print("---test---")
        time.sleep(1)

p = Process(target=test)
p.start() #新进程开始执行

p.join() #等子进程结束后，才继续执行
print('---main---')
````

### process子类

```python
from multiprocessing import Process
import os
import time

class Process_class(Process):
    def __init__(self, interval):
        Process.__init__(self)
        self.interval = interval

    # 重写run方法
    def run(self):
        print("子进程(%s)开始执行，父进程为(%s)" % (os.getpid(), os.getppid()))
        t_start = time.time()
        time.sleep(self.interval)
        t_stop = time.time()
        print("(%s)执行结束，耗时%0.2f秒"%(os.getpid(), os.getppid()))


if __name__ == "__main__":
    t_start = time.time()
    print("当前程序进程(%s)"%os.getpid())
    p1 = Process_class(2)
    # 对不包含target属性的Process类执行start()方法，会调用类中的run()
    p1.start()
    p1.join()
    print('子进程结束')
```





## 进程间通信(Queue)

先进先出

* Queue.put(item, [block[, timeout]]) 将item消息写入队列，block默认为True
* Queue.full() 如果队列满了，返回True，反正返回False
* Queue.get([block, [,timeout]]) 获取队列中的一条消息，然后将其从队列中移除，block默认为True
* Queue.get_nowait() 相当于Queue.get(False)
* Queue.put(item, [block[, timeout]]) 将item消息写入队列，block默认值为True
* Queue.qsize() 反悔当前队列消息数量
* Queue.empty() 如果队列为空，返回True，反之返回False
* Queue.put_nowait(item) 相当于Queue.put(item, False)

### 使用process形式

```python
from multiprocessing import Queue, Process
import os, time, random

# 写数据进程执行的代码
def write(q):
    for val in ['A', 'B', 'C']:
        print('put %s to queue....' % val)
        q.put(val)
        time.sleep(random.random())

# 读数据进程执行代码
def read(q):
    while True:
        if not q.empty():
            val = q.get(True)
            print('Get %s from queue' % val)
            time.sleep(random.random())
        else:
            break



if __name__ == '__main__':
    # 父进程创建Queue,并传递给子进程
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q, ))

    # 启动写子进程，写入
    pw.start()
    pw.join() # 等待结束

    print('----')

    # 启动读子进程
    pr.start()
    pr.join()
```

### 进程池使用进程间通信

```python
from multiprocessing import Manager,Pool
import os, time, random

def reader(q):
    print("reader启动(%s), 父进程为(%s)" % (os.getpid(), os.getppid()))
    for i in range(q.qsize()):
        print("reader从Queue中获取消息:%s"%q.get(True))


def writer(q):
    print("write启动(%s),父进程(%s)"%(os.getpid(), os.getppid()))
    for i in "dongGe":
        q.put(i)

if __name__ == "__main__":
    print("%s start" % os.getpid())
    q = Manager().Queue() #使用Manager中的Queue来初始化
    po=Pool()

    #使用阻塞模式
    po.apply(writer, (q,))
    po.apply(reader, (q,))

    po.close()
    po.join()
    print("(%s) End" % os.getpid())
```











