# 多任务编程

**调度算法方式**

* 时间片轮转
* 优先级调度

**概念**

* 并发 任务有部分被执行
* 并行 任务都被执行

## 进程

* 编码完毕在没运行时是程序
* 当程序运行并拥有的资源环境叫进程

### fork(子进程)

```python
# windows不支持
import os 
import time


ret = os.fork()
if ret == 0: # 子进程
    while True:
        print('--1--')
        time.sleep(3)
else:	#主（父）进程
    while True:
        print('--2--')
        time.sleep(3)
```

### getpid、getppid()

* `getpid()` 进程id
* `gitppid()` 父进程id

```python
import os 
import time

ret = os.fork()
print('main')	#父子进程都执行

if ret > 0:
    print('--父进程--%d'%os.getpid())
else:
    print('--子进程--%d--%d'%(os.getpid(), os.getppid()))
```

###主进程子进程结束

```python
import os 
import time

ret = os.fork()
if ret == 0:
    print('---子进程---start')
    time.sleep(5)
    print('---子进程---end')
else:
    print('----父进程---start')
    time.sleep(3)
    print('---父进程---end')

print('----over----')
```

进程退出彼此没有关系

### 变量共享

父进程和子进程之间变量不共享

```python
import os
import time

g_num = 100

ret = os.fork()
if ret==0:
    print("子进程")
    g_num += 1
    print('g_num = %d' % g_num)	
else:
    time.sleep(3)
    print('父进程')
    print('g_num = %d ==' % g_num)
```

### 多个fork

```python
import os
import time

g_num = 100

ret = os.fork()
if ret==0:
    print('---1---')
else:
    print('---2---')


ret = os.fork()
if ret==0:
    print('---1---')
else:
    print('---2---')
    
'''
---2---
---1---
---2---
---2---
---1---
---1---
'''
```

**fork炸弹**

```python
import os
while True:
    os.fork()
```

##multiprocessing

### process([group [, target [, name [, args [, kwargs]]]]])

- target：表示这个进程实例所调用对象；
- args：表示调用对象的位置参数元组；
- kwargs：表示调用对象的关键字参数字典；
- name：为当前进程实例的别名；
- group：大多数情况下用不到；

类常用方法：

- is_alive()：判断进程实例是否还在执行；
- join([timeout])：是否等待进程实例执行结束，或等待多少秒；
- start()：启动进程实例（创建子进程）；
- run()：如果没有给定target参数，对这个对象调用start()方法时，就将执行对象中的run()方法；
- terminate()：不管任务是否完成，立即终止；

类常用属性：

- name：当前进程实例别名，默认为Process-N，N为从1开始递增的整数；
- pid：当前进程实例的PID值；

```python
from multiprocessing import Process
import time

def test():
    while True:
        print("---test---")
        time.sleep(1)

p = Process(target=test) # target指定执行的代码
p.start() #新进程开始执行

while True:
    print('---main---')
    time.sleep(1)
```

此时主进程并不会因为执行完成后就退出

```python
import time

def test():
    while True:
        print("---test---")
        time.sleep(1)

p = Process(target=test)
p.start()
```

**join()**

````python
from multiprocessing import Process
import time

def test():
    for x in range(10):
        print("---test---")
        time.sleep(1)

p = Process(target=test)
p.start() #新进程开始执行

p.join() #等子进程结束后，才继续执行
print('---main---')
````

### process子类

```python
from multiprocessing import Process
import os
import time

class Process_class(Process):
    def __init__(self, interval):
        Process.__init__(self)
        self.interval = interval

    # 重写run方法
    def run(self):
        print("子进程(%s)开始执行，父进程为(%s)" % (os.getpid(), os.getppid()))
        t_start = time.time()
        time.sleep(self.interval)
        t_stop = time.time()
        print("(%s)执行结束，耗时%0.2f秒"%(os.getpid(), os.getppid()))


if __name__ == "__main__":
    t_start = time.time()
    print("当前程序进程(%s)"%os.getpid())
    p1 = Process_class(2)
    # 对不包含target属性的Process类执行start()方法，会调用类中的run()
    p1.start()
    p1.join()
    print('子进程结束')
```

## 进程池

```python
from multiprocessing import Pool
import os, time, random

def worker(msg):
    t_start = time.time()
    print("%s开始执行，进程号%d"%(msg, os.getpid()))
    #random.random() 随机生成0~1之间的浮点数
    time.sleep(random.random() * 2)
    t_stop = time.time()
    print(msg, '执行完毕，耗时%0.2f'%(t_stop - t_start))

po = Pool(3) #定义进程池，最大进程数为3

for i in range(0, 10):
    # apply_async(要调用的目标, (传递给目标的参数元组))
    # 每次循环将会空闲出来的子进程去调用目标
    po.apply_async(worker, (i,)) # 非堵塞的方式

# 主进程不会主动等待子进程结束
print('---start---')
po.close() # 关闭进程池，关闭后po不再接受新的请求
po.join() # 等待po中所有子进程执行完成，必须放在close语句之后
print('---end---')
```

进程pid只有三个，任务会以一种队列的形式依次执行

### 堵塞方式

```python
    po.apply(worker, (i,)) # 堵塞的方式,将等待上一进程完成后添加任务
```

## 进程间通信(Queue)

先进先出

* Queue.put(item, [block[, timeout]]) 将item消息写入队列，block默认为True
* Queue.full() 如果队列满了，返回True，反正返回False
* Queue.get([block, [,timeout]]) 获取队列中的一条消息，然后将其从队列中移除，block默认为True
* Queue.get_nowait() 相当于Queue.get(False)
* Queue.put(item, [block[, timeout]]) 将item消息写入队列，block默认值为True
* Queue.qsize() 反悔当前队列消息数量
* Queue.empty() 如果队列为空，返回True，反之返回False
* Queue.put_nowait(item) 相当于Queue.put(item, False)

### 使用process形式

```python
from multiprocessing import Queue, Process
import os, time, random

# 写数据进程执行的代码
def write(q):
    for val in ['A', 'B', 'C']:
        print('put %s to queue....' % val)
        q.put(val)
        time.sleep(random.random())

# 读数据进程执行代码
def read(q):
    while True:
        if not q.empty():
            val = q.get(True)
            print('Get %s from queue' % val)
            time.sleep(random.random())
        else:
            break



if __name__ == '__main__':
    # 父进程创建Queue,并传递给子进程
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q, ))

    # 启动写子进程，写入
    pw.start()
    pw.join() # 等待结束

    print('----')

    # 启动读子进程
    pr.start()
    pr.join()
```

### 进程池使用进程间通信

```python
from multiprocessing import Manager,Pool
import os, time, random

def reader(q):
    print("reader启动(%s), 父进程为(%s)" % (os.getpid(), os.getppid()))
    for i in range(q.qsize()):
        print("reader从Queue中获取消息:%s"%q.get(True))


def writer(q):
    print("write启动(%s),父进程(%s)"%(os.getpid(), os.getppid()))
    for i in "dongGe":
        q.put(i)

if __name__ == "__main__":
    print("%s start" % os.getpid())
    q = Manager().Queue() #使用Manager中的Queue来初始化
    po=Pool()

    #使用阻塞模式
    po.apply(writer, (q,))
    po.apply(reader, (q,))

    po.close()
    po.join()
    print("(%s) End" % os.getpid())
```

###文件拷贝

```python
from multiprocessing import Pool,Manager
import os,time

def copyFileTask(name, oldFolderName, newFolderName, queue):
    "完成copy一个文件的功能"
    o_fileName = oldFolderName+ '/' + name
    n_filename = newFolderName+ '/' + name

    fr = open(o_fileName, "r")
    fw = open(n_filename, "w")

    content = fr.read()
    fw.write(content)

    fr.close()
    fw.close()

    queue.put(n_filename)
    time.sleep(0.1)

def main():
    # 0. 获取被拷贝文件夹的名字
    oldFolderName = input("请输入您期望拷贝的文件夹名称：")

    # 1. 创建一个新的文件夹
    newFolderName = oldFolderName + '_copy'
    os.mkdir(newFolderName)

    # 2. 获得old文件夹中所有文件的名字
    fileList = os.listdir(oldFolderName)
    #print(fileList)

    # 3. 使用多进程的方式Copy 原文件夹中的所有文件到新的文件夹
    pool = Pool(5)
    queue = Manager().Queue()

    for name in fileList:
        pool.apply_async(copyFileTask, args=(name, oldFolderName, newFolderName, queue))

    num = 0
    all_num = len(fileList)
    print(all_num)
    while num < all_num:
        queue.get()
        num += 1
        print(num)
        copyRate = num/all_num

        #print("\rcopy的进度是：%.2f%%" % (copyRate*100), end="")
        time.sleep(0.3)

    # pool.close()
    # pool.join() #等待进程池  任务执行完毕

 
if __name__ == "__main__":
    main()

```

## 线程

### threading

```python
import threading
import time

def saySorry():
    print("----")
    time.sleep(1)

if __name__ == "__main__":
    for i in range(5):
        t = threading.Thread(target=saySorry)
        t.start() #启动线程，让线程开始执行
```

主线程等待子线程执行完毕后退出

### 使用Thread子类完成创建多线程

```python
import threading
import time

class MyThread(threading.Thread):
    def run(self):
        for i in range(8):
            time.sleep(1)
            msg = "I'm " + self.name + ' @ '+ str(i) # name属性中保存的是当前线程的名字
            print(msg)

if __name__ == '__main__':
    t = MyThread()
    t.start()
```

* 僵尸进程：子进程结束，但是父进程没有对子进程进行回收，此时子进程称谓僵尸进程
* 孤儿进程：父进程结束，子进程没有结束，子进程称孤儿进程

### 线程执行的顺序

```python
import threading
import time

class MyThread(threading.Thread):
    def run(self):
        for i in range(5):
            time.sleep(1)
            msg = "I'm "+ self.name +' @ ' + str(i)
            print(msg)

def test():
    for i in range(5):
        t = MyThread()
        t.start()

if __name__ == "__main__":
    test()
```

* 线程创建有顺序，线程执行顺序不固定


###线程共享全局变量

```python
from threading import Thread
import time

g_num = 100

def work1():
    global g_num
    for i in range(3):
        g_num += 1
   
    print("--- in work1, g_num is %d ---" % g_num)

def work2():
    global g_num
    print("--- in work2, g_num is %d ---" % g_num)

print("--- 线程创建之前g_num is %d ---" % g_num)

t1 = Thread(target=work1)
t1.start()

#延时一会儿，保证t1线程中的事情做完
time.sleep(1)

t2 = Thread(target=work2)
t2.start()
```

* 可能脏读

### 列表当作线程间参数传递

```python
from threading import Thread
import time

def work1(nums):
    nums.append(44)
    print("---in work1---", nums)

def work2(nums):
    #延时一会儿,保证t1线程中的事情执行完成
    time.sleep(1)
    print('--- in work2 ---', nums)

g_nums = [11, 22, 33]

t1 = Thread(target = work1, args=(g_nums,)) 
t1.start()

t2 = Thread(target = work2, args=(g_nums,))
t2.start()
```

### 避免全局变量赋值

####标记位

* 设置标记位，当作锁机制

```python
from threading import Thread
import time

g_num = 0 
g_flag = 1

def test1():
    global g_num
    global g_flag
    if g_flag == 1:
        for i in range(10000):
            g_num += 1

        g_flag = 0

    print('---Test1---g_num = %d' % g_num)

def test2():
    global g_num
    while True: # 程序不会因为标记位不满足而等待，而是继续运行，所以增加循环,这是一种轮训
        if g_flag != 1:
            for i in range(10000):
                g_num += 1
            break
    
    print('---Test2---g_num=%d'%g_num)

p1 = Thread(target=test1)
p1.start()

p2 = Thread(target=test2)
p2.start()
```

#### 互斥锁

```python
from threading import Thread,Lock
import time

g_num = 0 

def test1():
    global g_num

    mutex.acquire() #锁定
    for i in range(10000):
        g_num += 1

    mutex.release() # 解锁
    print('---Test1---g_num = %d' % g_num)

def test2():
    global g_num

    mutex.acquire() #锁定，当锁定时程序将在此处等待
    for i in range(10000):
        g_num += 1
    
    mutex.release()
    print('---Test2---g_num=%d'%g_num)


mutex = Lock()  #创建一把互斥锁

p1 = Thread(target=test1)
p1.start()

p2 = Thread(target=test2)
p2.start()
```

###非共享变量

线程内部的变量是相互独立的

* `threading.current_thread()` 返回当前线程信息 

### 死锁问题

```python
import threading
import time

class MyThread1(threading.Thread):
    def run(self):
        if muteA.acquire(): #锁定
            print(self.name + '---do1---up---')
            time.sleep(1)
        
            if muteB.acquire():
                print(self.name + '---do1---down---')
                muteB.release() #释放锁
            muteA.release()


class MyThread2(threading.Thread):
    def run(self):
        if muteB.acquire(): #锁定
            print(self.name + '---do2---up---')
            time.sleep(1)

            if muteA.acquire():
                print(self.name + '---d02---down---')
                muteA.release()
            muteB.release()


muteA = threading.Lock()
muteB = threading.Lock()

if __name__ == '__main__':
    t1 = MyThread1()
    t2 = MyThread2()
    t1.start()
    t2.start()
```

**死锁解决**

* acquire(blocking=True, timeout=-1) 以堵塞形式，timeout设置等待时间


##生产者与消费者

```python
#encoding=utf-8
import threading
import time
#python2中
#from Queue import Queue
#python3中

from queue import Queue
class Producer(threading.Thread):
    def run(self):
        global queue
        count = 0
        while True:
            if queue.qsize() < 1000:
                for i in range(100):
                    count = count +1
                    msg = '生成产品'+str(count)
                    queue.put(msg)
                    print(msg)
            time.sleep(0.5)


class Consumer(threading.Thread):
    def run(self):
        global queue
        while True:
            if queue.qsize() > 100:
                for i in range(3):
                    msg = self.name + '消费了 '+queue.get()
                    print(msg)
            time.sleep(1)

if __name__ == '__main__':
    queue = Queue()
    for i in range(500):
        queue.put('初始产品'+str(i))
    for i in range(2):
        p = Producer()
        p.start()
    for i in range(5):
        c = Consumer()
        c.start()
```

### ThreadLocal

1. 使用全局字典，以唯一键区别（threading.current_thread()）

2. threadlocal，线程间变量隔离

   ```python
   import threading

   #创建全局ThreadLocal对象
   local_school = threading.local()

   def process_student():
       # 获取当前线程关联的student
       std = local_school.student
       print('Hello, %s (in %s)' % (std, threading.current_thread().name))

   def process_thread(name):
       #绑定ThreadLocal的student
       local_school.student = name
       process_student()

   t1 = threading.Thread(target=process_thread, args=('xinbingliang', ), name='Thread-A')
   t2 = threading.Thread(target=process_thread, args=('老王', ), name='Thread-A')

   t1.start()
   t2.start()

   t1.join()
   t2.join()
   ```

## 异步

```python
from multiprocessing import Pool
import time
import os

def test():
    print("--- 进程池中的进程--pid=%d,ppid=%d ---"%(os.getpid(), os.getppid()))

    for i in range(3):
        print('---%d---' % i)
        time.sleep(1)
    return "hahah"

def test2(args):
    print("---callback func--pid=%d---" % os.getpid())
    print("---callback func--args=%s" % args)

pool = Pool(3)
pool.apply_async(func=test, callback=test2)

while True:
    time.sleep(1)
    print('---主进程-pid=%d---'%os.getpid())
```

## GIL