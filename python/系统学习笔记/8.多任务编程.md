# 多任务编程

**调度算法方式**

* 时间片轮转
* 优先级调度

**概念**

* 并发 任务有部分被执行
* 并行 任务都被执行

## 进程

* 编码完毕在没运行时是程序
* 当程序运行并拥有的资源环境叫进程

### fork(子进程)

```python
# windows不支持
import os 
import time


ret = os.fork()
if ret == 0: # 子进程
    while True:
        print('--1--')
        time.sleep(3)
else:	#主（父）进程
    while True:
        print('--2--')
        time.sleep(3)
```

### getpid、getppid()

* `getpid()` 进程id
* `gitppid()` 父进程id

```python
import os 
import time

ret = os.fork()
print('main')	#父子进程都执行

if ret > 0:
    print('--父进程--%d'%os.getpid())
else:
    print('--子进程--%d--%d'%(os.getpid(), os.getppid()))
```

###主进程子进程结束

```python
import os 
import time

ret = os.fork()
if ret == 0:
    print('---子进程---start')
    time.sleep(5)
    print('---子进程---end')
else:
    print('----父进程---start')
    time.sleep(3)
    print('---父进程---end')

print('----over----')
```

进程退出彼此没有关系

### 变量共享

父进程和子进程之间变量不共享

```python
import os
import time

g_num = 100

ret = os.fork()
if ret==0:
    print("子进程")
    g_num += 1
    print('g_num = %d' % g_num)	
else:
    time.sleep(3)
    print('父进程')
    print('g_num = %d ==' % g_num)
```

### 多个fork

```python
import os
import time

g_num = 100

ret = os.fork()
if ret==0:
    print('---1---')
else:
    print('---2---')


ret = os.fork()
if ret==0:
    print('---1---')
else:
    print('---2---')
    
'''
---2---
---1---
---2---
---2---
---1---
---1---
'''
```

**fork炸弹**

```python
import os
while True:
    os.fork()
```

##multiprocessing

### process([group [, target [, name [, args [, kwargs]]]]])

- target：表示这个进程实例所调用对象；
- args：表示调用对象的位置参数元组；
- kwargs：表示调用对象的关键字参数字典；
- name：为当前进程实例的别名；
- group：大多数情况下用不到；

类常用方法：

- is_alive()：判断进程实例是否还在执行；
- join([timeout])：是否等待进程实例执行结束，或等待多少秒；
- start()：启动进程实例（创建子进程）；
- run()：如果没有给定target参数，对这个对象调用start()方法时，就将执行对象中的run()方法；
- terminate()：不管任务是否完成，立即终止；

类常用属性：

- name：当前进程实例别名，默认为Process-N，N为从1开始递增的整数；
- pid：当前进程实例的PID值；

```python
from multiprocessing import Process
import time

def test():
    while True:
        print("---test---")
        time.sleep(1)

p = Process(target=test) # target指定执行的代码
p.start() #新进程开始执行

while True:
    print('---main---')
    time.sleep(1)
```

此时主进程并不会因为执行完成后就退出

```python
import time

def test():
    while True:
        print("---test---")
        time.sleep(1)

p = Process(target=test)
p.start()
```

**join()**

````python
from multiprocessing import Process
import time

def test():
    for x in range(10):
        print("---test---")
        time.sleep(1)

p = Process(target=test)
p.start() #新进程开始执行

p.join() #等子进程结束后，才继续执行
print('---main---')
````

### process子类

```python
from multiprocessing import Process
import os
import time

class Process_class(Process):
    def __init__(self, interval):
        Process.__init__(self)
        self.interval = interval

    # 重写run方法
    def run(self):
        print("子进程(%s)开始执行，父进程为(%s)" % (os.getpid(), os.getppid()))
        t_start = time.time()
        time.sleep(self.interval)
        t_stop = time.time()
        print("(%s)执行结束，耗时%0.2f秒"%(os.getpid(), os.getppid()))


if __name__ == "__main__":
    t_start = time.time()
    print("当前程序进程(%s)"%os.getpid())
    p1 = Process_class(2)
    # 对不包含target属性的Process类执行start()方法，会调用类中的run()
    p1.start()
    p1.join()
    print('子进程结束')
```















