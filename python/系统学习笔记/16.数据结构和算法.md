# 数据结构和算法

##概念

###五大特征

1. **输入**: 算法具有0个或多个输入
2. **输出**: 算法至少有1个或多个输出
3. **有穷性**: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成
4. **确定性**：算法中的每一步都有确定的含义，不会出现二义性
5. **可行性**：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成

###衡量

* 执行时间反应算法效率
* 时间复杂度：用运算执行的基本运算数量来表示，用T(n)函数描述，更关注数量级
* 大O表示法：（g(n) = n^3），剔除所有相关系数
* 最坏时间复杂度：由于数据不同产生的步骤数量不同，指需要执行的最大当执行步骤
* 平均时间复杂度：


###计算时间复杂度

1. 基本操作，即只有常数项，认为其时间复杂度为O(1)
2. 顺序结构，时间复杂度按**加法**进行计算
3. 循环结构，时间复杂度按**乘法**进行计算
4. 分支结构，时间复杂度**取最大值**
5. 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略
6. 在没有特殊说明时，我们所分析的算法的时间复杂度都是指**最坏时间复杂度**

### python内置性能分析

timeit模块可以用来测试一小段Python代码的执行速度。

####class timeit.Timer(stmt='pass', setup='pass', timer=<timer function>)

* Timer是测量小段代码执行速度的类。
* stmt参数是要测试的代码语句（statment）；
* setup参数是运行代码时需要的设置；
* timer参数是一个定时器函数，与平台有关。

#### timeit.Timer.timeit(number=1000000)

Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。

````python
import timeit

def test1():
    li = []
    for i in range(10000):
        li.append(i)

def test2():
    li = []
    for i in range(10000):
        li += [i]

def test3():
    li = [i for i in range(10000)]

def test4():
    li = list(range(10000))


timer1 = timeit.Timer("test1", "from __main__ import test1")
print(timer1.timeit(1000))
````

**list时间复杂度**

![](./img/list操作.png)

**dict内置操作的时间复杂度**

![](./img/dict操作.png)

## 顺序表

* 在申请空间时已经固定整个空间的大小
* 存储内容在组织上是连续的
* 有一体式结构和分离式结构

`list`就是顺序表实现的，O(1)，分离式，动态存储表的倍增

## 链表

* 在上一个节点中保存下一个数据块的信息
* 单向列表
* 头节点，尾节点

### 节点实现

```python
class Node(object):
    """节点类"""

    def __init__(self, item):
        """
        elem为节点数据
        """
        self.item =item
        self.next = None


class SingleLinkList():
    """单链表"""

    def __init__(self, node=None):
        self.__head = node #私有头

    def is_empty(self):
        """链表是否为空"""
        return (None == self.__head)

    def length(self):
        """链表长度"""
        cur = self.__head    # 指向当元素
        count = 0   # 索引个数

        while None != cur:
            cur = cur.next
            count += 1

        return count

    def travel(self):
        """遍历整个链表"""
        cur = self.__head

        while None != cur:
            print(cur.item)
            cur = cur.next

    def add(self, item):
        """链表头部添加元素"""
        node = Node(item)
        node.next = self.__head
        self.__head = node

    def append(self, item):
        """链表尾部添加元素"""
        node = Node(item)

        if self.is_empty():
            self.__head = node
        else:
            cur = self.__head
            while cur.next != None:
                cur = cur.next

            cur.next = node

    def insert(self, index, item):
        """指定位置添加元素"""
        if index <= 0:
            self.add(item)
            return
        elif index > self.length():
            self.append(item)
            return

        node = Node(item)
        pre = self.__head
        count = 0

        while (index - 1) >= count:
            pre = pre.next
            count += 1


        node.next = pre.next
        pre.next = node

    def remove(self, item):
        """删除节点"""
        cur = self.__head
        pre = None
        while Node != cur:
            if cur.item == item:
                if None == pre:
                    self.__head = cur.next
                else:
                    pre.next = cur.next
                break
            else:
                pre = cur
                cur = cur.next


    def serch(self, item):
        """查找节点是否存在"""
        cur = self.__head
        while None != cur:
            if cur.item == item:
                return True
            else:
                cur = cur.next

        return False
```



## 栈



## 队列



## 排序和搜索



## 树和算法









