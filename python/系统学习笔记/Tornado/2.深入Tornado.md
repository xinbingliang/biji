# 深入Tornado

## Application

### steeings

Application类的构造函数接收很多关于tornado web应用的配置参数

**debug**，设置tornado是否工作在调试模式，默认为False即工作在生产模式。当设置debug=True 后，tornado会工作在调试/开发模式，在此种模式下，tornado为方便我们开发而提供了几种特性：

- **自动重启**，tornado应用会监控我们的源代码文件，当有改动保存后便会重启程序，这可以减少我们手动重启程序的次数。需要注意的是，一旦我们保存的更改有错误，自动重启会导致程序报错而退出，从而需要我们保存修正错误后手动启动程序。这一特性也可单独通过autoreload=True设置；
- **取消缓存编译的模板**，可以单独通过compiled_template_cache=False来设置；
- **取消缓存静态文件hash值**，可以单独通过static_hash_cache=False来设置；
- **提供追踪信息**，当RequestHandler或者其子类抛出一个异常而未被捕获后，会生成一个包含追踪信息的页面，可以单独通过serve_traceback=True来设置。

使用debug参数的方法：

```python
import tornado.web
app = tornado.web.Application([], debug=True)
```

### 路由映射

使用路由传递一些信息

````python
# -*- coding: utf-8 -*-

import tornado.web
import tornado.ioloop
import tornado.httpserver
import tornado.options
from tornado.web import url

tornado.options.define('port', default=8080, type=int, help="run server on the given port.")

class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hello World!")

class XinHandler(tornado.web.RequestHandler):
    def initialize(self, subject):
        self.subject = subject

    def get(self):
        self.write(self.subject)



if __name__ == "__main__":

    app = tornado.web.Application([
        (r'/', IndexHandler),
        (r"/cpp", XinHandler, {"subject": "c++"}),
        url(r"/python", XinHandler, {"subject": "python"}, name="python_url")
    ], debug=True)

    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(tornado.options.options.port)
    tornado.ioloop.IOLoop.current().start()
````

## 输入

### 获取查询字符串参数

* get_query_argument(name, default=_ARG_DEFAULT, strip=True)
  * 从请求的查询字符串中返回指定参数name的值，如果出现多个同名参数，则返回最后一个的值。
  * default为设值未传name参数时返回的默认值，如若default也未设置，则会抛出tornado.web.MissingArgumentError异常。
  * strip表示是否过滤掉左右两边的空白字符，默认为过滤。
* get_query_arguments(name, strip=True)
  * 从请求的查询字符串中返回指定参数name的值，注意返回的是list列表（即使对应name参数只有一个值）。若未找到name参数，则返回空列表[]。
  * strip同前，不再赘述。

```python
# -*- coding: utf-8 -*-

import tornado.web
import tornado.ioloop
import tornado.httpserver
import tornado.options
from tornado.web import url, RequestHandler

tornado.options.define('port', default=8080, type=int, help="run server on the given port.")

class IndexHandler(RequestHandler):
    def get(self):
        # subject = self.get_query_argument('a', default=None, strip=True) # 重复参数显示最后一个
        subjects = self.get_query_arguments('a', strip=True)

        self.write(str(subjects))

if __name__ == "__main__":

    app = tornado.web.Application([
        (r'/', IndexHandler),
    ], debug=True)

    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(tornado.options.options.port)
    tornado.ioloop.IOLoop.current().start()
```

### 获取请求体参数

* get_argument(name, default=_ARG_DEFAULT, strip=True)
  * 从请求体和查询字符串中返回指定参数name的值，如果出现多个同名参数，则返回最后一个的值。
  * default与strip同前，不再赘述。
* get_arguments(name, strip=True)
  * 从请求体和查询字符串中返回指定参数name的值，注意返回的是list列表（即使对应name参数只有一个值）。若未找到name参数，则返回空列表[]。
  * strip同前，不再赘述。

### 两类方法的整合

* get_argument(name, default=_ARG_DEFAULT, strip=True)
  * 从请求体和查询字符串中返回指定参数name的值，如果出现多个同名参数，则返回最后一个的值。
  * default与strip同前，不再赘述。
* get_arguments(name, strip=True)
  * 从请求体和查询字符串中返回指定参数name的值，注意返回的是list列表（即使对应name参数只有一个值）。若未找到name参数，则返回空列表[]。
  * strip同前，不再赘述。
* 若同名参数，使用body

### 关于其他信息

RequestHandler.request 对象存储了关于请求的相关信息，具体属性有：

- method HTTP的请求方式，如GET或POST;
- host 被请求的主机名；
- uri 请求的完整资源标示，包括路径和查询字符串；
- path 请求的路径部分；
- query 请求的查询字符串部分；
- version 使用的HTTP版本；
- **headers** 请求的协议头，是类字典型的对象，支持关键字索引的方式获取特定协议头信息，例如：request.headers["Content-Type"]
- **body** 请求体数据；
- **remote_ip** 客户端的IP地址；
- **files** 用户上传的文件，为字典类型，型如：

##### 文件上传

```python
{
  "form_filename1":[<tornado.httputil.HTTPFile>, <tornado.httputil.HTTPFile>],
  "form_filename2":[<tornado.httputil.HTTPFile>,],
  ... 
}
```

tornado.httputil.HTTPFile是接收到的文件对象，它有三个属性：

- filename 文件的实际名字，与form_filename1不同，字典中的键名代表的是表单对应项的名字；
- body 文件的数据实体；
- content_type 文件的类型。 这三个对象属性可以像字典一样支持关键字索引，如request.files["form_filename1"][0]["body"]。

````python
# coding:utf-8
import tornado.web
import tornado.ioloop
import tornado.httpserver
import tornado.options
from tornado.options import options, define
from tornado.web import RequestHandler

define('port', default=8080, type=int, help="run serveron the given port.")

class IndexxHandler(RequestHandler):
    def get(self):
        self.write("hello world")

class UploadHandler(RequestHandler):
    def post(self):
        files = self.request.files
        img_files = files.get('img') # 可能多张同name文件，

        if img_files:
            img_file = img_files[0]["body"] # 图片的数据
            file = open("./files.jpg", 'w+')
            file.write(img_file)
            file.close()
        self.write("ok")

if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application([
        (r"/", IndexxHandler),
        (r"/upload", UploadHandler)
    ])

    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.current().start()
````

### JSON数据获取

```python
# coding:utf-8
import tornado.web
import tornado.ioloop
import tornado.httpserver
import tornado.options
from tornado.options import options, define
from tornado.web import RequestHandler
import json

define('port', default=8080, type=int, help="run serveron the given port.")

class IndexHandler(RequestHandler):
    def post(self):
        print self.request.headers.get("Content-Type")
        if self.request.headers.get("Content-Type").startswith("application/json"):
            json_data = self.request.body
            json_args = json.loads(json_data)

            self.write(json_args['a'])

if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application([
        (r"/", IndexHandler),
    ], debug=True)

    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.current().start()
```

### 正则提取uri



## 输出

## 接口与调试顺序









