# 异步与WebSockets

## 认识异步

### 同步

```python
# coding:utf-8
import time

def long_io():
    print("开始耗时操作")
    time.sleep(5)
    print("完成耗时操作")
    result = "io result"
    return result

def req_a():
    print("开始请求处理A")
    ret = long_io()
    print(ret)
    print("完成处理请求A")

def req_b():
    print("开始请求处理B")
    print("完成处理请求B")


def req_c():
    print("开始请求处理C")
    print("完成处理请求C")

def main():
    req_a()
    req_b()
    req_c()

if __name__ == '__main__':
    main()
```

### 异步

#### 回调写法实现原理

`````python
# coding:utf-8
import time
import thread

def long_io(cb):
    def fun(callback):
        print("开始耗时操作")
        time.sleep(5)
        print("完成耗时操作")
        result = "io result"
        callback(result)

    thread.start_new_thread(fun, (cb,))

def on_finish(result):
    print("开始执行回调函数")
    print(result)
    print("回调函数执行完成")

def req_a():
    print("开始请求处理A")
    long_io(on_finish)
    print("离开处理请求A")


def req_b():
    print("开始请求处理B")
    print("完成处理请求B")


def req_c():
    print("开始请求处理C")
    print("完成处理请求C")

def main():
    req_a()
    req_b()
    req_c()

    while 1: # 主进程直接退出会导致不打印线程中的输出
        pass

if __name__ == '__main__':
    main()
`````

#### 协程写法实现原理

````python
# coding:utf-8
import time
import thread

gen = None

def long_io():
    def fun():
        global gen # 申明使用全局的
        print("开始耗时操作")
        time.sleep(5)
        print("完成耗时操作")
        result = "io result"
        try:
            gen.send(result)
        except StopIteration:
            pass
    thread.start_new_thread(fun,())

def req_a():
    print("开始请求处理A")
    ret = yield long_io()
    print(ret)
    print("离开处理请求A")


def req_b():
    print("开始请求处理B")
    print("完成处理请求B")


def req_c():
    print("开始请求处理C")
    print("完成处理请求C")

def main():
    global gen
    gen = req_a()
    gen.next()

    req_b()
    req_c()

    while 1: # 主进程直接退出会导致不打印线程中的输出
        pass

if __name__ == '__main__':
    main()
````



#### 升级版本



#### 最终版本





## Tornado异步



## Websocket





