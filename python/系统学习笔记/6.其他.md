# 其他

## 类装饰器

```python
class Test():
    def __call__(self):
        print('--- test ---')

t = Test()
t()
```

将函数指向对象

```python
class Test():
    def __init__(self, func):
        print('--- 初始化 ---')
        print('func name is %s' % func.__name__)
        self.__func = func


    def __call__(self):
        print('执行类装饰器中的功能')
        self.__func()

@Test
def test():
    print('--- test ---')

test()
```

## 元类

类也是[对象，也可以选择创建

类的动态创建

```
type(类名,由父类名称组成的元组(针对继承的情况，可以为空), 包含属性的字典(名称和值))
```

```python
def printNum(self):
    print("===num=%d===" % self.num)

type("Test" , (), {"printNum": printNum})


obj.__class__
```

### 控制元类的操作

```python
# python2
def upper_attr(future_class_name, future_class_parents, future_class_attr):
    
    # 遍历属性字典，把不是__开头的属性名字变成大写
    newAttr = {}
    for name,value in future_class_attr.items():
        if not name.startswith("__")
            newAttr[name.upper()] = value

    # 调用type来创建一个类
    return type(future_class_name, future_class_parents, newAttr)


class Foo(object):
    __metaclass__ = upper_attr  # 设置Foo类的元类为upper_attr
    bar = 'bip'


print(hasattr(Foo, 'bar'))
print(hasattr(Foo, 'BAR'))

f = Foo()
print(f.BAR)

# python3
def upper_attr(future_class_name, future_class_parents, future_class_attr):
    
    # 遍历属性字典，把不是__开头的属性名字变成大写
    newAttr = {}
    for name,value in future_class_attr.items():
        if not name.startswith("__")
            newAttr[name.upper()] = value

    # 调用type来创建一个类
    return type(future_class_name, future_class_parents, newAttr)


class Foo(object, metaclass = upper_attr):
    bar = 'bip'


print(hasattr(Foo, 'bar'))
print(hasattr(Foo, 'BAR'))

f = Foo()
print(f.BAR)
```

## 垃圾回收机制

### 小整数对象池

[-5, 257) 提前创建的值，之间的值只有一份，单个字母也是一样，常驻内存。

### 大整数对象池

不在以上范围内，但不提前创建。

###intern机制

多个相同字符串共用一份，中间包含特殊符号时不共享。

### 引用计数（为主）

 对象引用计数为0时删除，

### 隔代回收（为辅）

Ruby：标记清除

Python：引用为0，立即回收，在内部维护一个链表，当满足一定条件所有对象引用减一，以触发回收机制

### gc的使用

* `gc.get_count()`当前自动执行垃圾回收的计数器，返回一个长度为3的列表
* `gc.get_threshold()` 返回gc模块中自动执行垃圾回收的频率
* `sys.getrefcount(a)`  计算引用计数
* `gc.enable()` 开启gc
* `gc.disable()` 关闭gc
* `gc.collect()` 执行垃圾回收
* `gc.garbage()` 打印清理的对象


### 内建属性

|     **常用专有属性**     |   **说明**   |          **触发方式**           |
| :----------------: | :--------: | :-------------------------: |
|     `__init__`     |    构造函数    |   创建实例，赋值时，在`__new__`后触发    |
|     `__new__`      |    生成实例    |            创建实例时            |
|    `__class__`     |   实例所在的类   |       实例.`__class__`        |
|     `__str__`      |  实例字符串表示   | print(实例)，没有实现时使用`__repr__` |
|     `__repr__`     |  实例字符串表示   |       类实例回车或print(实例)       |
|     `__del__`      |     析构     |           del删除实例           |
|     `__dict__`     |  实例自定义属性   |     `vars(实例.__dict__)`     |
|     `__doc__`      | 类文档，子类不继承  |         help(类或实例)          |
| `__getattribute__` |  属性访问拦截器   |           访问实例属性时           |
|    `__bases__`     | 类的所有父类构成元素 |       类名.`__bases__`        |

**属性拦截实验**

````python
class Obj(object):
    def __init__(self, subject1):
        self.subject1 = subject1
        self.subject2 = 'cpp'
        
    #属性访问是进行拦截
    def __getattribute__(self, obj):
        if obj == 'subject1':
            return 'in python'
        else:
            return object.__getattribute__(self, obj)

    def show(self):
        print('-----')
    

o = Obj('python')
print(o.subject1)
o.show() # 方法调用也会进行拦截
````

## 内建方法

### range

* `python2` 全部创建，`python3` 一个个返回，`python2`可以使用`xrange()`
* `(x+2 for x in range(5))`为生成器，`[x+2 for xx in range(5)]` 列表生成器

### map函数

````python
map(lambda x: x*x, [1, 2, 3] )

map(lambda x, y: x + y, [1, 2, 3], [4, 5, 6])


def f1(x, y):
    return (x, y)

l1 = [0, 1, 2, 3, 4, 5, 6]
l2 = ['Sun', 'M', 'T', 'W', 'T', 'F', 'S']

l3 = map(f1, l1, l2)

print(list(l3))
````

### filter函数
















