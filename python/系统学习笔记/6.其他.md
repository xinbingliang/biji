# 其他

## 类装饰器

```python
class Test():
    def __call__(self):
        print('--- test ---')

t = Test()
t()
```

将函数指向对象

```python
class Test():
    def __init__(self, func):
        print('--- 初始化 ---')
        print('func name is %s' % func.__name__)
        self.__func = func


    def __call__(self):
        print('执行类装饰器中的功能')
        self.__func()

@Test
def test():
    print('--- test ---')

test()
```

## 元类

类也是[对象，也可以选择创建

类的动态创建

```
type(类名,由父类名称组成的元组(针对继承的情况，可以为空), 包含属性的字典(名称和值))
```

```python
def printNum(self):
    print("===num=%d===" % self.num)

type("Test" , (), {"printNum": printNum})


obj.__class__
```

### 控制元类的操作

```python
# python2
def upper_attr(future_class_name, future_class_parents, future_class_attr):
    
    # 遍历属性字典，把不是__开头的属性名字变成大写
    newAttr = {}
    for name,value in future_class_attr.items():
        if not name.startswith("__")
            newAttr[name.upper()] = value

    # 调用type来创建一个类
    return type(future_class_name, future_class_parents, newAttr)


class Foo(object):
    __metaclass__ = upper_attr  # 设置Foo类的元类为upper_attr
    bar = 'bip'


print(hasattr(Foo, 'bar'))
print(hasattr(Foo, 'BAR'))

f = Foo()
print(f.BAR)

# python3
def upper_attr(future_class_name, future_class_parents, future_class_attr):
    
    # 遍历属性字典，把不是__开头的属性名字变成大写
    newAttr = {}
    for name,value in future_class_attr.items():
        if not name.startswith("__")
            newAttr[name.upper()] = value

    # 调用type来创建一个类
    return type(future_class_name, future_class_parents, newAttr)


class Foo(object, metaclass = upper_attr):
    bar = 'bip'


print(hasattr(Foo, 'bar'))
print(hasattr(Foo, 'BAR'))

f = Foo()
print(f.BAR)
```



